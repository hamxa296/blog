
// firebase-init.js
/**
 * firebase-init.js
 * This file initializes the Firebase application. It should be the first
 * Firebase-related script loaded on any page.
 */

// TODO: Replace the following with your app's Firebase project configuration
// from the Firebase console.
const firebaseConfig = {
    apiKey: "AIzaSyC1Q9tIEHLqAKZj6IjJN8aPiQCAPYbsi7I",
    authDomain: "giki-chronicles.firebaseapp.com",
    projectId: "giki-chronicles",
    storageBucket: "giki-chronicles.firebasestorage.app",
    messagingSenderId: "80968785263",
    appId: "1:80968785263:web:666d2e69fef2ef6f5a5c9a"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

// Make auth and firestore services available globally
const auth = firebase.auth();
const db = firebase.firestore();

// Flag to prevent duplicate user creation during the same session
let userDocumentCreated = false;
let authStateInitialized = false;

// Set authentication persistence to LOCAL (persists across browser sessions)
// This ensures the user stays logged in when switching tabs or refreshing pages
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
    .then(() => {
        console.log("Authentication persistence set to LOCAL");
    })
    .catch((error) => {
        console.error("Error setting auth persistence:", error);
    });

// Function to handle user data synchronization
const syncUserData = async (user) => {
    if (!user || !user.uid || !user.email) {
        console.log("Incomplete user data, cannot sync");
        return false;
    }

    try {
        // Store comprehensive user info in localStorage for cross-page access
        const userInfo = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email?.split('@')[0] || 'User',
            photoURL: user.photoURL || '',
            lastSignIn: new Date().toISOString()
        };
        
        localStorage.setItem('currentUser', JSON.stringify(userInfo));
        console.log("User info stored in localStorage:", userInfo);
        
        // Ensure user document exists in Firestore with correct data
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (!userDoc.exists && !userDocumentCreated) {
            console.log("Creating new user document with actual user data");
            const userData = {
                uid: user.uid,
                email: user.email,
                displayName: user.displayName || user.email?.split('@')[0] || 'User',
                photoURL: user.photoURL || '',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            // Only add isAdmin field for admin accounts
            if (typeof isAdminUID === 'function' && isAdminUID(user.uid)) {
                userData.isAdmin = true;
            }
            
            await db.collection('users').doc(user.uid).set(userData);
            userDocumentCreated = true; // Prevent duplicate creation
            console.log("User document created successfully");
        } else if (userDoc.exists) {
            // Update existing document with current user data (but preserve admin status)
            const existingData = userDoc.data();
            console.log("Updating existing user document, preserving admin status:", existingData.isAdmin);
            await db.collection('users').doc(user.uid).update({
                email: user.email,
                displayName: user.displayName || user.email?.split('@')[0] || 'User',
                photoURL: user.photoURL || '',
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log("User document updated with current data");
        } else {
            console.log("User document already created in this session, skipping...");
        }
        
        return true;
    } catch (error) {
        console.error("Error syncing user data:", error);
        return false;
    }
};

// Enhanced authentication state listener with better user data handling
// Wait for Firebase Auth to be fully initialized before setting up the listener
auth.onAuthStateChanged(async (user) => {
    console.log("=== AUTH STATE CHANGED ===");
    console.log("User object:", user);
    console.log("Current auth state:", user ? "SIGNED IN" : "SIGNED OUT");
    console.log("Auth state initialized:", authStateInitialized);
    
    if (user) {
        console.log("User is signed in:", user.email);
        console.log("User UID:", user.uid);
        console.log("User displayName:", user.displayName);
        console.log("User photoURL:", user.photoURL);
        
        // Validate that we have proper user data before proceeding
        if (!user.uid || !user.email) {
            console.log("Incomplete user data, waiting for full authentication...");
            return;
        }
        
        // Sync user data
        const syncSuccess = await syncUserData(user);
        if (syncSuccess) {
            console.log("User data synchronized successfully");
        }
        
    } else {
        console.log("User is signed out");
        // Clear user info from localStorage
        localStorage.removeItem('currentUser');
        // Reset the flag for next session
        userDocumentCreated = false;
    }
    
    // Mark auth state as initialized
    authStateInitialized = true;
    
    // Dispatch custom event to notify other scripts
    window.dispatchEvent(new CustomEvent('authStateChanged', { 
        detail: { user: user, initialized: true } 
    }));
});

// Function to check if user data is properly loaded
const ensureUserDataLoaded = async () => {
    const currentUser = auth.currentUser;
    if (!currentUser) {
        console.log("No current user, cannot ensure data loaded");
        return false;
    }
    
    // Check if we have user data in localStorage
    const storedUser = localStorage.getItem('currentUser');
    if (!storedUser) {
        console.log("No stored user data, syncing...");
        return await syncUserData(currentUser);
    }
    
    try {
        const parsedUser = JSON.parse(storedUser);
        if (parsedUser.uid !== currentUser.uid) {
            console.log("Stored user UID doesn't match current user, syncing...");
            return await syncUserData(currentUser);
        }
        
        console.log("User data already loaded and synchronized");
        return true;
    } catch (error) {
        console.error("Error parsing stored user data:", error);
        return await syncUserData(currentUser);
    }
};

// Make the function globally available
window.ensureUserDataLoaded = ensureUserDataLoaded;

// Debug function to check current authentication state
window.checkAuthState = function() {
    const currentUser = auth.currentUser;
    console.log("=== CURRENT AUTH STATE ===");
    console.log("Current user:", currentUser);
    console.log("Is signed in:", !!currentUser);
    console.log("Auth state initialized:", authStateInitialized);
    if (currentUser) {
        console.log("User email:", currentUser.email);
        console.log("User UID:", currentUser.uid);
        console.log("User displayName:", currentUser.displayName);
    }
    
    // Check localStorage
    const storedUser = localStorage.getItem('currentUser');
    console.log("Stored user in localStorage:", storedUser ? JSON.parse(storedUser) : null);
    
    return currentUser;
};

// Debug function to force re-authentication check
window.forceAuthCheck = function() {
    console.log("Forcing authentication state check...");
    auth.onAuthStateChanged((user) => {
        console.log("Auth state check result:", user);
    });
};

// Debug function to manually sync user data
window.syncUserDataNow = function() {
    const currentUser = auth.currentUser;
    if (currentUser) {
        return syncUserData(currentUser);
    } else {
        console.log("No current user to sync");
        return Promise.resolve(false);
    }
};


// admin-config.js
/**
 * admin-config.js
 * Centralized admin configuration for the application
 */

// Array of admin UIDs - add new admin UIDs here
const ADMIN_UIDS = [
    "DNDjKZRt0yQNh4d3inNchRcs0oY2", // Your working admin account
    "zCINcUAy84aMwHF83wlRUTO2Dn32",
    "gn2AlkdswANjVg58rUXOLoPaX192"
];

/**
 * Checks if a user UID is in the admin list
 * @param {string} uid - The user UID to check
 * @returns {boolean} - True if the user is an admin
 */
function isAdminUID(uid) {
    return ADMIN_UIDS.includes(uid);
}

/**
 * Gets all admin UIDs
 * @returns {string[]} - Array of admin UIDs
 */
function getAdminUIDs() {
    return [...ADMIN_UIDS]; // Return a copy to prevent modification
}

// Make functions globally available
window.isAdminUID = isAdminUID;
window.getAdminUIDs = getAdminUIDs;
window.ADMIN_UIDS = ADMIN_UIDS; 

// auth.js
/**
 * auth.js
 * This file contains the core Firebase authentication functions.
 * It now also handles creating user profile documents in Firestore upon sign-up.
 */

/*
    FIRESTORE DATABASE STRUCTURE for the 'users' collection:

    Each document will be identified by the user's UID from Authentication.
    - uid (string): The user's unique ID.
    - email (string): The user's email address.
    - displayName (string): The user's public name (can be edited).
    - photoURL (string): The URL for the user's profile picture.
    - bio (string, optional): A short user biography.
    - isAdmin (boolean, optional): Set to true for administrators.
*/

/**
 * Signs up a new user and creates their profile in Firestore.
 */
async function signUpUser(email, password) {
    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        const user = userCredential.user;

        // Create a user document in the 'users' collection
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: email.split('@')[0], // Default display name is the part of the email before the @
            photoURL: '', // Default empty profile picture
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        // Only add isAdmin field for admin accounts
        if (typeof isAdminUID === 'function' && isAdminUID(user.uid)) {
            userData.isAdmin = true;
        }
        
        await db.collection('users').doc(user.uid).set(userData);

        return { success: true, user: user };
    } catch (error) {
        console.error("Sign-up Error:", error);
        return { success: false, error: error.message };
    }
}

/**
 * Signs in a user with Google and creates/updates their profile in Firestore.
 */
async function signInWithGoogle() {
    try {
        const provider = new firebase.auth.GoogleAuthProvider();
        const result = await auth.signInWithPopup(provider);
        const user = result.user;

        // Create or update the user document in the 'users' collection
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName,
            photoURL: user.photoURL
        };
        
        // Only add isAdmin field for admin accounts
        if (typeof isAdminUID === 'function' && isAdminUID(user.uid)) {
            userData.isAdmin = true;
        }
        
        // { merge: true } prevents overwriting existing fields if the user already has a profile
        await db.collection('users').doc(user.uid).set(userData, { merge: true });

        return { success: true, user: user };
    } catch (error) {
        console.error("Google Sign-in Error:", error);
        return { success: false, error: error.message };
    }
}


/**
 * Logs in an existing user with their email and password.
 */
async function loginUser(email, password) {
    try {
        const userCredential = await auth.signInWithEmailAndPassword(email, password);
        const user = userCredential.user;
        
        // Ensure user document exists in Firestore
        try {
            const userDoc = await db.collection('users').doc(user.uid).get();
            if (!userDoc.exists) {
                console.log("Creating missing user document for existing user");
                const userData = {
                    uid: user.uid,
                    email: user.email || email,
                    displayName: user.displayName || email.split('@')[0],
                    photoURL: user.photoURL || '',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Only add isAdmin field for admin accounts
                if (typeof isAdminUID === 'function' && isAdminUID(user.uid)) {
                    userData.isAdmin = true;
                }
                
                await db.collection('users').doc(user.uid).set(userData);
            }
        } catch (firestoreError) {
            console.error("Error ensuring user document exists:", firestoreError);
            // Continue with login even if Firestore fails
        }
        
        return { success: true, user: user };
    } catch (error) {
        console.error("Login Error:", error);
        return { success: false, error: error.message };
    }
}

/**
 * Logs out the currently signed-in user.
 */
async function logoutUser() {
    try {
        await auth.signOut();
        return { success: true };
    } catch (error) {
        console.error("Logout Error:", error);
        return { success: false, error: error.message };
    }
}

/**
 * Checks the current authentication state of the user.
 */
function onAuthStateChange(callback) {
    return auth.onAuthStateChanged(callback);
}

/**
 * Checks if the current user is an admin.
 * @returns {Promise<boolean>}
 */
async function isUserAdmin() {
    const user = auth.currentUser;
    console.log("isUserAdmin called, current user:", user ? user.uid : "No user");
    
    if (!user) return false;
    
    try {
        // First, ensure user data is loaded
        if (typeof window.ensureUserDataLoaded === 'function') {
            await window.ensureUserDataLoaded();
        }
        
        console.log("Fetching user document for:", user.uid);
        const userDoc = await db.collection('users').doc(user.uid).get();
        console.log("User document exists:", userDoc.exists);
        
        if (!userDoc.exists) {
            console.log("User document does not exist - this should be handled by auth state listener");
            return false;
        }
        
        const userData = userDoc.data();
        console.log("User data:", userData);
        console.log("isAdmin value:", userData.isAdmin);
        
        const isAdmin = userData.isAdmin === true; // Explicitly check for true
        console.log("Final admin result:", isAdmin);
        return isAdmin;
    } catch (error) {
        console.error("Error checking admin status:", error);
        return false;
    }
}


// gallery.js
/**
 * gallery.js
 * Handles all Firestore interactions for the photo gallery.
 */

/*
    FIRESTORE DATABASE STRUCTURE:

    'galleryPhotos' collection:
    - imageUrl (string): The URL of the image from Cloudinary.
    - fullSizeUrl (string): The full-size URL for fullscreen viewing.
    - caption (string): The user-submitted caption.
    - category (string): e.g., "Academic Blocks", "Hostels".
    - uploaderName (string): Name of the user who submitted.
    - uploaderId (string): UID of the user who submitted.
    - cloudinaryId (string): Cloudinary public ID for deletion.
    - isHighlighted (boolean): Whether this photo should be featured in the slideshow.
    - status (string): "approved", "pending", or "rejected"
    - createdAt (timestamp): When the photo was submitted.
    - reviewedAt (timestamp): When the photo was reviewed (for approved/rejected)
    - reviewedBy (string): UID of the admin who reviewed the photo
    - rejectionReason (string): Optional reason for rejection
*/

/**
 * Fetches all photos from the gallery by status with pagination.
 * @param {string} status - "approved", "pending", "rejected", or "all"
 * @param {number} page - Page number (0-based)
 * @param {number} limit - Number of photos per page
 * @returns {Promise<object>}
 */
async function getGalleryPhotos(status = "approved", page = 0, limit = 12) {
    try {
        let query;
        if (status === "all") {
            query = db.collection("galleryPhotos")
                .orderBy("createdAt", "desc");
        } else {
            query = db.collection("galleryPhotos")
                .where("status", "==", status)
                .orderBy("createdAt", "desc");
        }
        
        // Apply pagination
        if (page > 0) {
            // For pagination, we need to get the last document from the previous page
            let prevPageQuery;
            if (status === "all") {
                prevPageQuery = db.collection("galleryPhotos")
                    .orderBy("createdAt", "desc")
                    .limit(page * limit);
            } else {
                prevPageQuery = db.collection("galleryPhotos")
                    .where("status", "==", status)
                    .orderBy("createdAt", "desc")
                    .limit(page * limit);
            }
            
            const prevPageSnapshot = await prevPageQuery.get();
            const lastDoc = prevPageSnapshot.docs[prevPageSnapshot.docs.length - 1];
            
            if (lastDoc) {
                query = query.startAfter(lastDoc);
            }
        }
        
        const snapshot = await query.limit(limit).get();
        const photos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        return { success: true, photos };
    } catch (error) {
        console.error("Error fetching gallery photos:", error);
        return { success: false, error: "Could not load photos." };
    }
}

/**
 * Fetches highlighted photos for the slideshow.
 * @returns {Promise<object>}
 */
async function getHighlightedPhotos() {
    try {
        // Avoid composite index by fetching highlighted approved and sorting client-side
        const snapshot = await db.collection("galleryPhotos")
            .where("status", "==", "approved")
            .where("isHighlighted", "==", true)
            .get();
        const photos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        photos.sort((a, b) => {
            const at = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt || 0);
            const bt = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt || 0);
            return bt - at;
        });
        return { success: true, photos };
    } catch (error) {
        console.error("Error fetching highlighted photos:", error);
        return { success: false, error: "Could not load highlighted photos." };
    }
}

/**
 * Toggles the highlighted status of a photo.
 * @param {string} photoId - The ID of the photo to toggle.
 * @param {boolean} isHighlighted - The new highlighted status.
 * @returns {Promise<object>}
 */
async function togglePhotoHighlight(photoId, isHighlighted) {
    try {
        await db.collection("galleryPhotos").doc(photoId).update({
            isHighlighted: isHighlighted
        });
        return { success: true };
    } catch (error) {
        console.error("Error toggling photo highlight:", error);
        return { success: false, error: "Could not update photo status." };
    }
}

/**
 * Saves a new photo for review by an administrator.
 * @param {string} caption - The photo caption.
 * @param {string} category - The photo category.
 * @param {File} file - The image file to upload.
 * @returns {Promise<object>}
 */
async function submitPhotoForReview(caption, category, file) {
    const user = auth.currentUser;
    if (!user) return { success: false, error: "You must be logged in to submit a photo." };

    try {
        // --- Cloudinary Upload Logic ---
        const cloudName = "dfkpmldma";
        const uploadPreset = "giki-chronicles";
        const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`;

        const formData = new FormData();
        formData.append("file", file);
        formData.append("upload_preset", uploadPreset);
        // NOTE: Keep minimal parameters for maximum compatibility with unsigned presets
        // If you want eager transformations, whitelist them in your unsigned preset
        // and then uncomment the next line:
        // formData.append("eager", "c_fill,w_1200,h_800,q_auto,f_auto");

        const response = await fetch(url, {
            method: "POST",
            body: formData,
        });

        if (!response.ok) {
            let detail = '';
            try { detail = await response.text(); } catch (_) {}
            throw new Error(`Image upload failed${detail ? `: ${detail}` : ''}`);
        }

        const data = await response.json();
        if (!data.secure_url) {
            throw new Error(`Upload response missing URL${data.error?.message ? `: ${data.error.message}` : ''}`);
        }
        const imageUrl = data.secure_url;
        const cloudinaryId = data.public_id;
        const fullSizeUrl = imageUrl; // Use original as full-size; add eager if preset supports it

        // --- Save to Firestore Gallery (Pending Review) ---
        await db.collection("galleryPhotos").add({
            imageUrl, // Thumbnail URL
            fullSizeUrl, // Full size URL
            caption,
            category,
            uploaderId: user.uid,
            uploaderName: user.displayName || user.email,
            cloudinaryId,
            isHighlighted: false, // Admin can change on approval
            status: "pending",
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        });

        return { success: true, message: "Photo submitted for review!" };

    } catch (error) {
        console.error("Error submitting photo:", error);
        return { success: false, error: "Failed to submit photo." };
    }
} 

// --- Admin Functions for Gallery Management ---

/**
 * Fetches photos by status for admin review with pagination.
 * @param {string} status - "pending", "approved", "rejected"
 * @param {number} page - Page number (0-based)
 * @param {number} limit - Number of photos per page
 * @returns {Promise<object>}
 */
async function getGalleryPhotosByStatus(status, page = 0, limit = 12) {
    try {
        let query = db.collection("galleryPhotos")
            .where("status", "==", status)
            .orderBy("createdAt", "desc");
        
        // Apply pagination
        if (page > 0) {
            // For pagination, we need to get the last document from the previous page
            const prevPageQuery = db.collection("galleryPhotos")
                .where("status", "==", status)
                .orderBy("createdAt", "desc")
                .limit(page * limit);
            
            const prevPageSnapshot = await prevPageQuery.get();
            const lastDoc = prevPageSnapshot.docs[prevPageSnapshot.docs.length - 1];
            
            if (lastDoc) {
                query = query.startAfter(lastDoc);
            }
        }
        
        const snapshot = await query.limit(limit).get();
        const photos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        return { success: true, photos };
    } catch (error) {
        console.error(`Error fetching ${status} gallery photos:`, error);
        return { success: false, error: `Could not load ${status} photos.` };
    }
}

/**
 * Updates the status of a gallery photo (approve/reject).
 * @param {string} photoId - The ID of the photo to update.
 * @param {string} newStatus - The new status ("approved", "rejected").
 * @param {object} options - Additional options like rejection reason, highlight status.
 * @returns {Promise<object>}
 */
async function updateGalleryPhotoStatus(photoId, newStatus, options = {}) {
    const user = auth.currentUser;
    if (!user) return { success: false, error: "Authentication required." };

    try {
        const updateData = { 
            status: newStatus,
            reviewedAt: firebase.firestore.FieldValue.serverTimestamp(),
            reviewedBy: user.uid
        };
        
        if (typeof options.isHighlighted === 'boolean') {
            updateData.isHighlighted = options.isHighlighted;
        }
        
        if (newStatus === "rejected" && options.rejectionReason) {
            updateData.rejectionReason = options.rejectionReason;
        }

        await db.collection("galleryPhotos").doc(photoId).update(updateData);
        return { success: true };
    } catch (error) {
        console.error("Error updating gallery photo status:", error);
        return { success: false, error: "Could not update status." };
    }
}

/**
 * Deletes a photo from both Firestore and Cloudinary.
 * @param {string} photoId - The ID of the photo to delete.
 * @param {string} cloudinaryId - The Cloudinary public ID.
 * @returns {Promise<object>}
 */
async function deleteGalleryPhoto(photoId, cloudinaryId) {
    const user = auth.currentUser;
    if (!user) return { success: false, error: "Authentication required." };

    try {
        // First, delete from Cloudinary
        if (cloudinaryId) {
            const cloudName = "dfkpmldma";
            const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/destroy`;
            
            const formData = new FormData();
            formData.append("public_id", cloudinaryId);
            
            const response = await fetch(url, {
                method: "POST",
                body: formData,
            });

            if (!response.ok) {
                console.warn("Failed to delete from Cloudinary, but continuing with Firestore deletion");
            }
        }

        // Then delete from Firestore
        await db.collection("galleryPhotos").doc(photoId).delete();
        
        return { success: true, message: "Photo deleted successfully." };
    } catch (error) {
        console.error("Error deleting gallery photo:", error);
        return { success: false, error: "Could not delete photo." };
    }
}

/**
 * Gets photo statistics for admin dashboard.
 * @returns {Promise<object>}
 */
async function getGalleryStats() {
    try {
        const [approved, pending, rejected] = await Promise.all([
            db.collection("galleryPhotos").where("status", "==", "approved").get(),
            db.collection("galleryPhotos").where("status", "==", "pending").get(),
            db.collection("galleryPhotos").where("status", "==", "rejected").get()
        ]);

        return {
            success: true,
            stats: {
                approved: approved.size,
                pending: pending.size,
                rejected: rejected.size,
                total: approved.size + pending.size + rejected.size
            }
        };
    } catch (error) {
        console.error("Error fetching gallery stats:", error);
        return { success: false, error: "Could not load statistics." };
    }
}

// Legacy function for backward compatibility
async function getPendingGalleryPhotos() {
    return getGalleryPhotosByStatus("pending");
}

// gallery-admin.js
/**
 * gallery-admin.js
 * Handles admin functionality for photo gallery management
 */

let currentPhotoStatus = 'approved';
let currentPhoto = null;
let isAdmin = false;

// Pagination variables
let currentPage = 0;
const PHOTOS_PER_PAGE = 12;
let hasMorePhotos = true;
let isLoading = false;

// Initialize admin functionality
async function initializeGalleryAdmin() {
    // Check if user is admin
    const user = auth.currentUser;
    if (!user) return;

    try {
        const adminCheck = await isUserAdmin();
        isAdmin = adminCheck;
        
        if (isAdmin) {
            showAdminInterface();
            loadAdminStats();
        }
    } catch (error) {
        console.error('Error checking admin status:', error);
    }
}

// Show admin interface elements
function showAdminInterface() {
    // Check if we're on the gallery page (these elements only exist on gallery.html)
    const adminPhotoTabs = document.getElementById('admin-photo-tabs');
    const adminStats = document.getElementById('admin-stats');
    
    if (adminPhotoTabs) {
        // Remove 'hidden' but keep responsive classes - show on md+ screens only
        adminPhotoTabs.classList.remove('hidden');
        adminPhotoTabs.classList.add('hidden', 'md:flex');
    }
    
    if (adminStats) {
        // Remove 'hidden' but keep responsive classes - show on md+ screens only
        adminStats.classList.remove('hidden');
        adminStats.classList.add('hidden', 'md:block');
    }
    
    // Add event listeners for admin tabs (only if they exist)
    const tabApproved = document.getElementById('tab-approved');
    const tabPending = document.getElementById('tab-pending');
    const tabRejected = document.getElementById('tab-rejected');
    
    if (tabApproved) {
        tabApproved.addEventListener('click', () => switchPhotoTab('approved'));
        tabApproved.classList.add('bg-green-200');
    }
    
    if (tabPending) {
        tabPending.addEventListener('click', () => switchPhotoTab('pending'));
    }
    
    if (tabRejected) {
        tabRejected.addEventListener('click', () => switchPhotoTab('rejected'));
    }
}

// Switch between photo status tabs
async function switchPhotoTab(status) {
    currentPhotoStatus = status;
    
    // Update tab styling (only if we're on the gallery page)
    const adminPhotoTabs = document.querySelector('#admin-photo-tabs');
    if (adminPhotoTabs) {
        adminPhotoTabs.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('bg-green-200', 'bg-yellow-200', 'bg-red-200');
        });
        
        const activeTab = document.getElementById(`tab-${status}`);
        if (activeTab) {
            if (status === 'approved') activeTab.classList.add('bg-green-200');
            else if (status === 'pending') activeTab.classList.add('bg-yellow-200');
            else if (status === 'rejected') activeTab.classList.add('bg-red-200');
        }
    }
    
    // Load photos for selected status
    await loadPhotosByStatus(status);
}

// Load photos by status with pagination
async function loadPhotosByStatus(status, page = 0, append = false) {
    if (isLoading) return;
    isLoading = true;
    
    try {
        const result = await getGalleryPhotosByStatus(status, page, PHOTOS_PER_PAGE);
        if (result.success) {
            if (append) {
                appendPhotoGrid(result.photos, status);
            } else {
                renderPhotoGrid(result.photos, status);
            }
            hasMorePhotos = result.photos.length === PHOTOS_PER_PAGE;
            currentPage = page;
        } else {
            console.error('Error loading photos:', result.error);
        }
    } catch (error) {
        console.error('Error loading photos:', error);
    } finally {
        isLoading = false;
    }
}

// Load more photos (for infinite scroll)
async function loadMorePhotos() {
    if (!hasMorePhotos || isLoading) return;
    
    const nextPage = currentPage + 1;
    await loadPhotosByStatus(currentPhotoStatus, nextPage, true);
}

// Render photo grid with admin controls
function renderPhotoGrid(photos, status) {
    const grid = document.getElementById('gallery-grid');
    
    // Only proceed if we're on the gallery page
    if (!grid) {
        console.log('Gallery grid not found - not on gallery page');
        return;
    }
    
    grid.innerHTML = '';
    
    if (photos.length === 0) {
        grid.innerHTML = `
            <div class="col-span-full text-center py-12 text-gray-500">
                <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <h3 class="text-xl font-semibold mb-2">No ${status} photos</h3>
                <p>There are no ${status} photos to display.</p>
            </div>
        `;
        return;
    }
    
    photos.forEach(photo => {
        const photoCard = createPhotoCard(photo, status);
        grid.appendChild(photoCard);
    });
    
    // Add load more button if there are more photos
    if (hasMorePhotos) {
        addLoadMoreButton();
    }
    
    // Initialize lazy loading
    initializeLazyLoading();
}

// Append photos to existing grid (for pagination)
function appendPhotoGrid(photos, status) {
    const grid = document.getElementById('gallery-grid');
    
    // Only proceed if we're on the gallery page
    if (!grid) {
        console.log('Gallery grid not found - not on gallery page');
        return;
    }
    
    // Remove existing load more button
    const existingLoadMore = grid.querySelector('.load-more-container');
    if (existingLoadMore) {
        existingLoadMore.remove();
    }
    
    photos.forEach(photo => {
        const photoCard = createPhotoCard(photo, status);
        grid.appendChild(photoCard);
    });
    
    // Add load more button if there are more photos
    if (hasMorePhotos) {
        addLoadMoreButton();
    }
    
    // Initialize lazy loading for new images
    initializeLazyLoading();
}

// Add load more button
function addLoadMoreButton() {
    const grid = document.getElementById('gallery-grid');
    
    // Only proceed if we're on the gallery page
    if (!grid) {
        console.log('Gallery grid not found - not on gallery page');
        return;
    }
    
    const loadMoreContainer = document.createElement('div');
    loadMoreContainer.className = 'load-more-container col-span-full text-center py-8';
    loadMoreContainer.innerHTML = `
        <button onclick="loadMorePhotos()" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors">
            Load More Photos
        </button>
    `;
    grid.appendChild(loadMoreContainer);
}

// Create photo card with admin controls
function createPhotoCard(photo, status) {
    const card = document.createElement('div');
    card.className = 'bg-white rounded-xl shadow-lg overflow-hidden transform hover:-translate-y-2 transition-transform duration-300';
    
    const photoDate = photo.createdAt ? photo.createdAt.toDate().toLocaleDateString() : 'N/A';
    const statusBadge = getStatusBadge(status);
    
    // Generate optimized image URLs with different sizes
    const imageUrl = photo.imageUrl;
    let optimizedImageUrl = imageUrl;
    
    if (imageUrl.includes('cloudinary')) {
        // Fix the Cloudinary URL transformation to preserve aspect ratio
        // Use c_scale instead of c_fill to maintain original proportions
        // Original: https://res.cloudinary.com/dfkpmldma/image/upload/v1754675533/ebpkauzzsw0cjngi32hm.jpg
        // Should be: https://res.cloudinary.com/dfkpmldma/image/upload/c_scale,w_400,q_auto,f_auto/v1754675533/ebpkauzzsw0cjngi32hm.jpg
        
        if (imageUrl.includes('/upload/')) {
            optimizedImageUrl = imageUrl.replace('/upload/', '/upload/c_scale,w_400,q_auto,f_auto/');
        } else {
            // Fallback if the URL structure is different
            optimizedImageUrl = imageUrl;
        }
    }
    
    card.innerHTML = `
        <div class="relative">
            <img class="h-48 w-full object-cover cursor-pointer" 
                 loading="lazy"
                 src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%23f3f4f6'/%3E%3C/svg%3E"
                 data-src="${optimizedImageUrl}"
                 alt="${photo.caption}" 
                 onclick="openPhotoReview('${photo.id}')">
            ${statusBadge}
            <div class="absolute top-2 right-2 flex space-x-2">
                ${status === 'pending' ? `
                    <button onclick="approvePhoto('${photo.id}')" class="bg-green-500 text-white p-2 rounded-full hover:bg-green-600 transition-colors">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </button>
                    <button onclick="rejectPhoto('${photo.id}')" class="bg-red-500 text-white p-2 rounded-full hover:bg-red-600 transition-colors">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                ` : ''}
                <button onclick="deletePhoto('${photo.id}', '${photo.cloudinaryId}')" class="bg-gray-500 text-white p-2 rounded-full hover:bg-gray-600 transition-colors">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div class="p-6">
            <div class="flex items-center justify-between mb-2">
                <p class="text-sm text-gray-500">${photoDate} • by ${photo.uploaderName}</p>
                <span class="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full">${photo.category}</span>
            </div>
            <h4 class="text-xl font-semibold mb-3">${photo.caption}</h4>
            ${photo.rejectionReason ? `<p class="text-sm text-red-600 mb-2"><strong>Rejection Reason:</strong> ${photo.rejectionReason}</p>` : ''}
            <button onclick="openPhotoReview('${photo.id}')" class="font-semibold text-blue-600 hover:underline">View Details &rarr;</button>
        </div>
    `;
    
    return card;
}

// Get status badge HTML
function getStatusBadge(status) {
    const badges = {
        approved: '<span class="absolute top-2 left-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full">Approved</span>',
        pending: '<span class="absolute top-2 left-2 bg-yellow-500 text-white text-xs px-2 py-1 rounded-full">Pending</span>',
        rejected: '<span class="absolute top-2 left-2 bg-red-500 text-white text-xs px-2 py-1 rounded-full">Rejected</span>'
    };
    return badges[status] || '';
}

// Load admin statistics
async function loadAdminStats() {
    const result = await getGalleryStats();
    if (result.success) {
        const stats = result.stats;
        
        // Update gallery page stats (if we're on gallery.html)
        const statsApproved = document.getElementById('stats-approved');
        const statsPending = document.getElementById('stats-pending');
        const statsRejected = document.getElementById('stats-rejected');
        
        if (statsApproved) {
            statsApproved.textContent = `Approved: ${stats.approved}`;
        }
        if (statsPending) {
            statsPending.textContent = `Pending: ${stats.pending}`;
        }
        if (statsRejected) {
            statsRejected.textContent = `Rejected: ${stats.rejected}`;
        }
        
        // Update admin page stats (if we're on admin.html)
        const adminStatsApproved = document.getElementById('stats-approved-photos');
        const adminStatsPending = document.getElementById('stats-pending-photos');
        const adminStatsRejected = document.getElementById('stats-rejected-photos');
        
        if (adminStatsApproved) {
            adminStatsApproved.textContent = stats.approved;
        }
        if (adminStatsPending) {
            adminStatsPending.textContent = stats.pending;
        }
        if (adminStatsRejected) {
            adminStatsRejected.textContent = stats.rejected;
        }
    }
}

// Open photo review modal
async function openPhotoReview(photoId) {
    try {
        const doc = await db.collection("galleryPhotos").doc(photoId).get();
        if (!doc.exists) {
            alert('Photo not found');
            return;
        }
        
        currentPhoto = { id: photoId, ...doc.data() };
        
        const modal = document.getElementById('admin-review-modal');
        const content = document.getElementById('review-photo-content');
        
        // Only proceed if we're on the gallery page with the modal
        if (!modal || !content) {
            console.log('Photo review modal not found - not on gallery page');
            return;
        }
        
        content.innerHTML = `
            <div class="text-center">
                <img src="${currentPhoto.fullSizeUrl}" alt="${currentPhoto.caption}" class="max-w-full h-auto rounded-lg shadow-lg">
            </div>
            <div class="space-y-4">
                <div>
                    <h3 class="font-semibold text-lg">${currentPhoto.caption}</h3>
                    <p class="text-gray-600">${currentPhoto.category}</p>
                </div>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <strong>Uploaded by:</strong> ${currentPhoto.uploaderName}
                    </div>
                    <div>
                        <strong>Date:</strong> ${currentPhoto.createdAt ? currentPhoto.createdAt.toDate().toLocaleDateString() : 'N/A'}
                    </div>
                    <div>
                        <strong>Status:</strong> <span class="capitalize">${currentPhoto.status}</span>
                    </div>
                    ${currentPhoto.rejectionReason ? `
                        <div class="col-span-2">
                            <strong>Rejection Reason:</strong> ${currentPhoto.rejectionReason}
                        </div>
                    ` : ''}
                </div>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="highlight-photo" ${currentPhoto.isHighlighted ? 'checked' : ''} class="mr-2">
                        <span>Highlight in slideshow</span>
                    </label>
                </div>
            </div>
        `;
        
        modal.classList.remove('hidden');
        
        // Add event listeners
        const approveBtn = document.getElementById('approve-photo-btn');
        const rejectBtn = document.getElementById('reject-photo-btn');
        const closeBtn = document.getElementById('close-review-modal');
        
        if (approveBtn) approveBtn.onclick = () => approvePhoto(currentPhoto.id);
        if (rejectBtn) rejectBtn.onclick = () => rejectPhoto(currentPhoto.id);
        if (closeBtn) closeBtn.onclick = () => modal.classList.add('hidden');
        
    } catch (error) {
        console.error('Error opening photo review:', error);
        alert('Error loading photo details');
    }
}

// Approve photo
async function approvePhoto(photoId) {
    if (!confirm('Are you sure you want to approve this photo?')) return;
    
    const isHighlighted = document.getElementById('highlight-photo')?.checked || false;
    
    const result = await updateGalleryPhotoStatus(photoId, 'approved', { isHighlighted });
    if (result.success) {
        alert('Photo approved successfully!');
        
        // Close modal if it exists
        const modal = document.getElementById('admin-review-modal');
        if (modal) {
            modal.classList.add('hidden');
        }
        
        await switchPhotoTab(currentPhotoStatus);
        await loadAdminStats();
    } else {
        alert('Error approving photo: ' + result.error);
    }
}

// Reject photo
async function rejectPhoto(photoId) {
    const modal = document.getElementById('rejection-modal');
    
    // Only proceed if we're on the gallery page with the modal
    if (!modal) {
        console.log('Rejection modal not found - not on gallery page');
        return;
    }
    
    modal.classList.remove('hidden');
    
    const confirmBtn = document.getElementById('confirm-rejection');
    const cancelBtn = document.getElementById('cancel-rejection');
    const reasonInput = document.getElementById('rejection-reason');
    
    if (confirmBtn) {
        confirmBtn.onclick = async () => {
            const reason = reasonInput ? reasonInput.value : '';
            
            const result = await updateGalleryPhotoStatus(photoId, 'rejected', { rejectionReason: reason });
            if (result.success) {
                alert('Photo rejected successfully!');
                modal.classList.add('hidden');
                
                // Close admin review modal if it exists
                const adminModal = document.getElementById('admin-review-modal');
                if (adminModal) {
                    adminModal.classList.add('hidden');
                }
                
                if (reasonInput) reasonInput.value = '';
                await switchPhotoTab(currentPhotoStatus);
                await loadAdminStats();
            } else {
                alert('Error rejecting photo: ' + result.error);
            }
        };
    }
    
    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.classList.add('hidden');
            if (reasonInput) reasonInput.value = '';
        };
    }
}

// Delete photo
async function deletePhoto(photoId, cloudinaryId) {
    const modal = document.getElementById('delete-photo-modal');
    
    // Only proceed if we're on the gallery page with the modal
    if (!modal) {
        console.log('Delete photo modal not found - not on gallery page');
        return;
    }
    
    modal.classList.remove('hidden');
    
    const confirmBtn = document.getElementById('confirm-delete');
    const cancelBtn = document.getElementById('cancel-delete');
    
    if (confirmBtn) {
        confirmBtn.onclick = async () => {
            const result = await deleteGalleryPhoto(photoId, cloudinaryId);
            if (result.success) {
                alert('Photo deleted successfully!');
                modal.classList.add('hidden');
                await switchPhotoTab(currentPhotoStatus);
                await loadAdminStats();
            } else {
                alert('Error deleting photo: ' + result.error);
            }
        };
    }
    
    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.classList.add('hidden');
        };
    }
}

// Initialize lazy loading
function initializeLazyLoading() {
    const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.classList.remove('lazy');
                observer.unobserve(img);
            }
        });
    }, {
        rootMargin: '50px 0px',
        threshold: 0.01
    });

    // Observe all lazy images
    document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
    });
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Wait for auth to be ready
    auth.onAuthStateChanged((user) => {
        if (user) {
            initializeGalleryAdmin();
        }
    });
    
    // Initialize lazy loading for any existing images
    initializeLazyLoading();
});


// script.js
/*
    JavaScript for GIKI Chronicles Blog
    Handles main page logic, view switching, and initializes modules.
*/

document.addEventListener('DOMContentLoaded', () => {

    // --- Element Selections ---
    // Sidebar elements
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebar = document.getElementById('sidebar');
    const sidebarClose = document.getElementById('sidebar-close');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    
    // Legacy mobile menu elements (keeping for compatibility)
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    const homeTab = document.getElementById('home-tab');
    const eventsTab = document.getElementById('events-tab');
    const mobileHomeTab = document.getElementById('mobile-home-tab');
    const mobileEventsTab = document.getElementById('mobile-events-tab');
    const blogContent = document.getElementById('blog-content');
    const eventsContent = document.getElementById('events-content');

    // Event Details Modal elements
    const eventModal = document.getElementById('event-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalDate = document.getElementById('modal-date');
    const modalDescription = document.getElementById('modal-description');
    const googleCalendarLink = document.getElementById('google-calendar-link');
    const modalClose = document.getElementById('modal-close');
    const editEventButton = document.getElementById('edit-event-button');
    const deleteEventButton = document.getElementById('delete-event-button');

    // Add Event Modal elements
    const addEventModal = document.getElementById('add-event-modal');
    const addEventButton = document.getElementById('add-event-button');
    const addEventModalClose = document.getElementById('add-event-modal-close');
    const addEventForm = document.getElementById('add-event-form');

    // Edit Event Modal elements
    const editEventModal = document.getElementById('edit-event-modal');
    const editEventModalClose = document.getElementById('edit-event-modal-close');
    const editEventForm = document.getElementById('edit-event-form');

    // Delete Confirmation Modal elements
    const deleteConfirmModal = document.getElementById('delete-confirm-modal');
    const confirmDeleteButton = document.getElementById('confirm-delete-button');
    const cancelDeleteButton = document.getElementById('cancel-delete-button');


    let calendarInstance = null;
    let currentOpenEvent = null;

    // --- Modal Functions ---
    function openEventModal(event) {
        currentOpenEvent = event; // Store the event for potential editing or deletion
        const startDate = new Date(event.date);
        const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000);
        const formatGoogleDate = (date) => date.toISOString().replace(/-|:|\.\d+/g, '');
        const googleCalendarUrl = `https://www.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(event.title)}&dates=${formatGoogleDate(startDate)}/${formatGoogleDate(endDate)}&details=${encodeURIComponent(event.description)}&location=GIK%20Institute,%20Topi,%20Pakistan`;

        modalTitle.textContent = event.title;
        modalDate.textContent = startDate.toLocaleString('default', { dateStyle: 'full', timeStyle: 'short' });
        modalDescription.textContent = event.description;
        googleCalendarLink.href = googleCalendarUrl;

        eventModal.classList.remove('hidden');
    }

    function closeEventModal() {
        if (eventModal) eventModal.classList.add('hidden');
        currentOpenEvent = null;
    }

    function openAddEventModal() {
        if (addEventModal) addEventModal.classList.remove('hidden');
    }

    function closeAddEventModal() {
        if (addEventModal) addEventModal.classList.add('hidden');
    }

    function openEditEventModal(event) {
        if (!event) return;
        const eventDate = new Date(event.date);
        // Format date for datetime-local input (YYYY-MM-DDTHH:mm)
        const localDateTime = new Date(eventDate.getTime() - (eventDate.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);

        document.getElementById('edit-event-id').value = event.id;
        document.getElementById('edit-event-title').value = event.title;
        document.getElementById('edit-event-date').value = localDateTime;
        document.getElementById('edit-event-description').value = event.description;

        closeEventModal(); // Close the details modal first
        if (editEventModal) editEventModal.classList.remove('hidden');
    }

    function closeEditEventModal() {
        if (editEventModal) editEventModal.classList.add('hidden');
    }

    function openDeleteConfirmModal() {
        closeEventModal();
        if (deleteConfirmModal) deleteConfirmModal.classList.remove('hidden');
    }

    function closeDeleteConfirmModal() {
        if (deleteConfirmModal) deleteConfirmModal.classList.add('hidden');
    }

    // --- Calendar Initialization ---
    function initializeCalendar() {
        if (calendarInstance) {
            calendarInstance.render();
            return;
        }

        const calendarContainer = document.getElementById('calendar-container');
        const calendarTitle = document.getElementById('calendar-title');

        if (calendarContainer && calendarTitle && typeof Calendar !== 'undefined') {
            calendarInstance = new Calendar({
                container: calendarContainer,
                titleElement: calendarTitle,
                onEventClick: openEventModal
            });

            document.getElementById('prev-button').addEventListener('click', () => calendarInstance.previous());
            document.getElementById('next-button').addEventListener('click', () => calendarInstance.next());
            document.getElementById('year-view-button').addEventListener('click', () => calendarInstance.setView('year'));
            document.getElementById('month-view-button').addEventListener('click', () => calendarInstance.setView('month'));
            document.getElementById('week-view-button').addEventListener('click', () => calendarInstance.setView('week'));
            document.getElementById('day-view-button').addEventListener('click', () => calendarInstance.setView('day'));

            calendarInstance.render();
        } else {
            console.error("Calendar dependencies not found.");
        }
    }


    // --- Page View Switching ---
    function switchPage(view) {
        const showEvents = view === 'events';
        
        if (blogContent) {
            blogContent.classList.toggle('hidden', showEvents);
        }
        if (eventsContent) {
            eventsContent.classList.toggle('hidden', !showEvents);
        }

        document.querySelectorAll('#home-tab, #mobile-home-tab').forEach(tab => {
            if (tab) {
                tab.classList.toggle('text-blue-600', !showEvents);
                tab.classList.toggle('font-semibold', !showEvents);
            }
        });
        document.querySelectorAll('#events-tab, #mobile-events-tab').forEach(tab => {
            if (tab) {
                tab.classList.toggle('text-blue-600', showEvents);
                tab.classList.toggle('font-semibold', showEvents);
            }
        });

        if (showEvents) {
            initializeCalendar();
        }

        if (mobileMenu && !mobileMenu.classList.contains('hidden')) {
            mobileMenu.classList.add('hidden');
        }
    }

    // --- Sidebar Functions ---
    function openSidebar() {
        if (sidebar) sidebar.classList.remove('-translate-x-full');
        if (sidebarOverlay) sidebarOverlay.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
    }

    function closeSidebar() {
        if (sidebar) sidebar.classList.add('-translate-x-full');
        if (sidebarOverlay) sidebarOverlay.classList.add('hidden');
        document.body.style.overflow = '';
    }

    // --- Event Listeners ---
    // Sidebar listeners
    if (sidebarToggle) sidebarToggle.addEventListener('click', openSidebar);
    if (sidebarClose) sidebarClose.addEventListener('click', closeSidebar);
    if (sidebarOverlay) sidebarOverlay.addEventListener('click', closeSidebar);
    
    // Close sidebar when clicking on a link
    document.querySelectorAll('#sidebar a').forEach(link => {
        link.addEventListener('click', () => {
            setTimeout(closeSidebar, 100); // Small delay to allow navigation
        });
    });

    // Legacy mobile menu listeners
    if (mobileMenuButton && mobileMenu) {
        mobileMenuButton.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));
    }

    if (homeTab) homeTab.addEventListener('click', (e) => { e.preventDefault(); switchPage('blog'); });
    if (eventsTab) eventsTab.addEventListener('click', (e) => { e.preventDefault(); switchPage('events'); });
    if (mobileHomeTab) mobileHomeTab.addEventListener('click', (e) => { e.preventDefault(); switchPage('blog'); });
    if (mobileEventsTab) mobileEventsTab.addEventListener('click', (e) => { e.preventDefault(); switchPage('events'); });

    // Event Details Modal Listeners
    if (modalClose) modalClose.addEventListener('click', closeEventModal);
    if (eventModal) eventModal.addEventListener('click', (e) => { if (e.target === eventModal) closeEventModal(); });
    if (editEventButton) editEventButton.addEventListener('click', () => openEditEventModal(currentOpenEvent));
    if (deleteEventButton) deleteEventButton.addEventListener('click', openDeleteConfirmModal);


    // Add Event Modal Listeners
    if (addEventButton) addEventButton.addEventListener('click', openAddEventModal);
    if (addEventModalClose) addEventModalClose.addEventListener('click', closeAddEventModal);
    if (addEventModal) addEventModal.addEventListener('click', (e) => { if (e.target === addEventModal) closeAddEventModal(); });

    if (addEventForm) addEventForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const formData = new FormData(addEventForm);
        const newEvent = {
            title: formData.get('title'),
            date: new Date(formData.get('date')).toISOString(),
            description: formData.get('description')
        };

        if (calendarInstance) {
            calendarInstance.addEvent(newEvent);
        }

        addEventForm.reset();
        closeAddEventModal();
    });

    // Edit Event Modal Listeners
    if (editEventModalClose) editEventModalClose.addEventListener('click', closeEditEventModal);
    if (editEventModal) editEventModal.addEventListener('click', (e) => { if (e.target === editEventModal) closeEditEventModal(); });

    if (editEventForm) editEventForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const formData = new FormData(editEventForm);
        const updatedEvent = {
            id: parseInt(formData.get('id')),
            title: formData.get('title'),
            date: new Date(formData.get('date')).toISOString(),
            description: formData.get('description')
        };

        if (calendarInstance) {
            calendarInstance.editEvent(updatedEvent);
        }

        editEventForm.reset();
        closeEditEventModal();
    });

    // Delete Confirmation Modal Listeners
    if (cancelDeleteButton) cancelDeleteButton.addEventListener('click', closeDeleteConfirmModal);
    if (deleteConfirmModal) deleteConfirmModal.addEventListener('click', (e) => { if (e.target === deleteConfirmModal) closeDeleteConfirmModal(); });
    if (confirmDeleteButton) confirmDeleteButton.addEventListener('click', () => {
        if (calendarInstance && currentOpenEvent) {
            calendarInstance.deleteEvent(currentOpenEvent.id);
        }
        closeDeleteConfirmModal();
    });

    // --- Initial State ---
    switchPage('blog'); // Start on the blog view
});


// app.js
/**
 * app.js
 * This is the main application script. It handles the integration
 * of frontend elements with the backend functions.
 */

document.addEventListener('DOMContentLoaded', async () => {
    console.log("App.js: DOM Content Loaded");
    
    // Wait a bit for Firebase to initialize
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check if user data needs to be loaded
    if (typeof window.ensureUserDataLoaded === 'function') {
        try {
            const currentUser = firebase.auth().currentUser;
            if (currentUser) {
                console.log("App.js: Ensuring user data is loaded on page load");
                await window.ensureUserDataLoaded();
            }
        } catch (error) {
            console.error("App.js: Error ensuring user data loaded on page load:", error);
        }
    }
    
    // --- Initialize Quill Editor ---
    let quill;
    if (document.getElementById('editor-container')) {
        // Clear any existing Quill instances
        const existingEditor = document.querySelector('.ql-editor');
        if (existingEditor) {
            existingEditor.remove();
        }
        
        // Clear the container
        const container = document.getElementById('editor-container');
        container.innerHTML = '';
        
        // Initialize new Quill instance
        quill = new Quill('#editor-container', {
            theme: 'snow',
            placeholder: 'Craft your story here...',
            modules: { toolbar: [[{ 'header': [1, 2, 3, false] }], ['bold', 'italic', 'underline'], [{ 'list': 'ordered' }, { 'list': 'bullet' }], ['link', 'image'], ['clean']] }
        });
    }

    // --- Authentication Logic (Login, Signup, Google) ---
    const loginForm = document.getElementById('login-form');
    if (loginForm) {
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const result = await loginUser(loginForm.email.value, loginForm.password.value);
            if (result.success) window.location.href = 'index.html';
            else document.getElementById('error-message').textContent = result.error;
        });
    }
    const signupForm = document.getElementById('signup-form');
    if (signupForm) {
        signupForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const result = await signUpUser(signupForm.email.value, signupForm.password.value);
            if (result.success) window.location.href = 'index.html';
            else document.getElementById('error-message').textContent = result.error;
        });
    }
    const googleSignInButton = document.getElementById('google-signin-button');
    if (googleSignInButton) {
        googleSignInButton.addEventListener('click', async () => {
            const result = await signInWithGoogle();
            if (result.success) window.location.href = 'index.html';
            else if (document.getElementById('error-message')) document.getElementById('error-message').textContent = result.error;
        });
    }

    // --- Post Form Logic (Handles both Create and Edit) ---
    const postForm = document.getElementById('post-form');
    if (postForm) {
        // Clear form message when user starts typing
        const clearFormMessage = () => {
            const formMessage = document.getElementById('form-message');
            if (formMessage && formMessage.textContent.includes('submitted successfully')) {
                formMessage.textContent = '';
                formMessage.className = 'text-center h-5';
            }
        };
        
        // Add event listeners to clear message when user starts editing
        const titleInput = document.getElementById('post-title');
        if (titleInput) {
            titleInput.addEventListener('input', clearFormMessage);
        }
        
        if (quill) {
            quill.on('text-change', clearFormMessage);
        }
        const urlParams = new URLSearchParams(window.location.search);
        const postIdToEdit = urlParams.get('edit');
        if (postIdToEdit) {
            document.getElementById('page-title').textContent = 'Edit Your Post';
            document.getElementById('page-subtitle').textContent = 'Make your changes and resubmit for review.';
            document.getElementById('submit-post-button').textContent = 'Update Post';
            document.getElementById('post-id').value = postIdToEdit;
            const loadPostForEditing = async () => {
                const result = await getPostForEditing(postIdToEdit);
                if (result.success) {
                    const post = result.post;
                    document.getElementById('post-title').value = post.title;
                    document.getElementById('post-description').value = post.description || '';
                    document.getElementById('post-photo-url').value = post.photoUrl || '';
                    document.getElementById('post-genre').value = post.genre || 'General';
                    document.getElementById('post-tags').value = post.tags ? post.tags.join(', ') : '';
                    quill.root.innerHTML = post.content;
                    
                    // If there's a photo URL, show it in the URL tab
                    if (post.photoUrl) {
                        if (urlTab && uploadTab) {
                            urlTab.click();
                        }
                    }
                } else {
                    document.getElementById('form-message').textContent = result.error;
                }
            };
            loadPostForEditing();
        }
        // --- Image Upload Functionality ---
        let uploadedImageUrl = null; // Store the uploaded image URL
        
        // Tab switching functionality
        const urlTab = document.getElementById('url-tab');
        const uploadTab = document.getElementById('upload-tab');
        const urlSection = document.getElementById('url-section');
        const uploadSection = document.getElementById('upload-section');
        
        if (urlTab && uploadTab) {
            urlTab.addEventListener('click', () => {
                urlTab.className = 'flex-1 py-2 px-3 text-sm font-medium bg-blue-600 text-white transition-colors';
                uploadTab.className = 'flex-1 py-2 px-3 text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors';
                urlSection.classList.remove('hidden');
                uploadSection.classList.add('hidden');
                // Clear uploaded image when switching to URL
                uploadedImageUrl = null;
            });
            
            uploadTab.addEventListener('click', () => {
                uploadTab.className = 'flex-1 py-2 px-3 text-sm font-medium bg-blue-600 text-white transition-colors';
                urlTab.className = 'flex-1 py-2 px-3 text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors';
                uploadSection.classList.remove('hidden');
                urlSection.classList.add('hidden');
                // Clear URL input when switching to upload
                document.getElementById('post-photo-url').value = '';
            });
        }
        
        // File upload handling
        const fileInput = document.getElementById('post-photo-file');
        const uploadProgress = document.getElementById('upload-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const uploadStatus = document.getElementById('upload-status');
        const uploadPreview = document.getElementById('upload-preview');
        const previewImage = document.getElementById('preview-image');
        const uploadedUrlSpan = document.getElementById('uploaded-url');
        const removeUploadBtn = document.getElementById('remove-upload');
        const uploadZone = document.querySelector('.border-dashed');
        
        // Upload function to avoid code duplication
        const uploadImage = async (file) => {
            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }
            
            // Validate file size (10MB limit)
            if (file.size > 10 * 1024 * 1024) {
                alert('File size must be less than 10MB.');
                return;
            }
            
            // Show upload progress
            uploadProgress.classList.remove('hidden');
            uploadStatus.textContent = 'Uploading to Cloudinary...';
            
            try {
                // Upload to Cloudinary
                const cloudName = "dfkpmldma";
                const uploadPreset = "giki-chronicles";
                const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`;
                
                const formData = new FormData();
                formData.append("file", file);
                formData.append("upload_preset", uploadPreset);
                
                // Simulate progress (Cloudinary doesn't provide real-time progress)
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress > 90) progress = 90;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${Math.round(progress)}%`;
                }, 200);
                
                const response = await fetch(url, {
                    method: "POST",
                    body: formData,
                });
                
                clearInterval(progressInterval);
                
                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.status}`);
                }
                
                const data = await response.json();
                uploadedImageUrl = data.secure_url;
                
                // Show completion
                progressBar.style.width = '100%';
                progressText.textContent = '100%';
                uploadStatus.textContent = 'Upload complete!';
                
                // Show preview
                previewImage.src = uploadedImageUrl;
                uploadedUrlSpan.textContent = uploadedImageUrl;
                uploadPreview.classList.remove('hidden');
                
                // Hide progress after a moment
                setTimeout(() => {
                    uploadProgress.classList.add('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('Upload error:', error);
                uploadStatus.textContent = 'Upload failed. Please try again.';
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                
                setTimeout(() => {
                    uploadProgress.classList.add('hidden');
                }, 3000);
            }
        };
        
        if (fileInput) {
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                await uploadImage(file);
            });
        }
        
        // Drag and drop functionality
        if (uploadZone) {
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            
            uploadZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
            });
            
            uploadZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    await uploadImage(files[0]);
                }
            });
        }
        
        // Remove uploaded image
        if (removeUploadBtn) {
            removeUploadBtn.addEventListener('click', () => {
                uploadedImageUrl = null;
                fileInput.value = '';
                uploadPreview.classList.add('hidden');
                uploadProgress.classList.add('hidden');
            });
        }
        
        postForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const formMessage = document.getElementById('form-message');
            if (!quill || quill.getLength() <= 1) {
                formMessage.textContent = 'Please write some content for your post.';
                formMessage.className = 'text-center h-5 text-red-600 font-medium';
                return;
            }
            formMessage.textContent = 'Submitting...';
            formMessage.className = 'text-center h-5 text-blue-600 font-medium';
            
            // Get photo URL from either URL input or uploaded image
            let photoUrl = '';
            if (uploadedImageUrl) {
                photoUrl = uploadedImageUrl;
            } else {
                photoUrl = document.getElementById('post-photo-url').value;
            }
            
            const postData = {
                title: document.getElementById('post-title').value,
                description: document.getElementById('post-description').value,
                photoUrl: photoUrl,
                genre: document.getElementById('post-genre').value,
                tags: document.getElementById('post-tags').value,
                content: quill.root.innerHTML
            };
            let result;
            const postId = document.getElementById('post-id').value;
            if (postId) {
                result = await updatePost(postId, postData);
            } else {
                result = await createPost(postData);
            }
            if (result.success) {
                formMessage.textContent = '✅ Your post has been submitted successfully! It will be reviewed and approved if it matches our guidelines.';
                formMessage.className = 'text-center h-5 text-green-600 font-medium';
                // Clear the form for a new post
                document.getElementById('post-title').value = '';
                document.getElementById('post-description').value = '';
                document.getElementById('post-photo-url').value = '';
                document.getElementById('post-genre').value = 'General';
                document.getElementById('post-tags').value = '';
                quill.setText('');
                
                // Clear uploaded image
                uploadedImageUrl = null;
                if (fileInput) fileInput.value = '';
                if (uploadPreview) uploadPreview.classList.add('hidden');
                if (uploadProgress) uploadProgress.classList.add('hidden');
                
                // Reset to URL tab
                if (urlTab && uploadTab) {
                    urlTab.click();
                }
                // Clear the hidden post ID if it was set
                document.getElementById('post-id').value = '';
                // Reset button text
                document.getElementById('submit-post-button').textContent = 'Submit for Review';
                // Reset page title and subtitle
                document.getElementById('page-title').textContent = 'Blog Editor';
                document.getElementById('page-subtitle').textContent = 'Your one-stop hub for student life, engineering marvels, and campus tales at GIKI Institute.';
            } else {
                formMessage.textContent = result.error;
                formMessage.className = 'text-center h-5 text-red-600 font-medium';
            }
        });
    }

    // --- Profile Page Logic ---
    const profileForm = document.getElementById('profile-form');
    if (profileForm) {
        const displayNameInput = document.getElementById('display-name');
        const userEmailInput = document.getElementById('user-email');
        const userBioInput = document.getElementById('user-bio');
        const profilePicImg = document.getElementById('profile-pic');
        const photoUploadButton = document.querySelector('#profile-pic + button');
        const photoUploadInput = document.getElementById('photo-upload');
        const formMessage = document.getElementById('form-message');
        const loadProfileData = async (user) => {
            if (!user) return;
            const result = await getUserProfile(user.uid);
            if (result.success) {
                const profile = result.profile;
                displayNameInput.value = profile.displayName || '';
                userEmailInput.value = profile.email || '';
                userBioInput.value = profile.bio || '';
                if (profile.photoURL) {
                    profilePicImg.src = profile.photoURL;
                }
            } else {
                const newProfile = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.displayName || user.email.split('@')[0],
                    photoURL: user.photoURL || '',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('users').doc(user.uid).set(newProfile);
                loadProfileData(user);
            }
        };
        if (photoUploadButton) {
            photoUploadButton.addEventListener('click', () => photoUploadInput.click());
        }
        if (photoUploadInput) {
            photoUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                const user = auth.currentUser;
                if (file && user) {
                    formMessage.textContent = 'Uploading...';
                    const uploadResult = await uploadProfilePicture(user.uid, file);
                    if (uploadResult.success) {
                        await updateUserProfile(user.uid, { photoURL: uploadResult.url });
                        profilePicImg.src = uploadResult.url;
                        formMessage.textContent = 'Photo updated!';
                    } else {
                        formMessage.textContent = uploadResult.error;
                    }
                }
            });
        }
        profileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const user = auth.currentUser;
            if (user) {
                formMessage.textContent = 'Saving...';
                const profileData = {
                    displayName: displayNameInput.value,
                    bio: userBioInput.value
                };
                const result = await updateUserProfile(user.uid, profileData);
                if (result.success) {
                    formMessage.textContent = 'Profile saved successfully!';
                } else {
                    formMessage.textContent = result.error;
                }
            }
        });
        const loadUserPosts = async (user) => {
            if (!user) return;
            const myPostsContainer = document.getElementById('my-posts-container');
            if (!myPostsContainer) return;
            const result = await getPostsByAuthor(user.uid);
            myPostsContainer.innerHTML = '';
            if (result.success && result.posts.length > 0) {
                result.posts.forEach(post => {
                    const postElement = document.createElement('div');
                    postElement.className = 'flex justify-between items-center p-4 border rounded-lg';
                    let statusColor = 'bg-yellow-200 text-yellow-800';
                    if (post.status === 'approved') {
                        statusColor = 'bg-green-200 text-green-800';
                    } else if (post.status === 'rejected') {
                        statusColor = 'bg-red-200 text-red-800';
                    }
                    postElement.innerHTML = `
                        <div>
                            <a href="post.html?id=${post.id}" class="font-bold text-lg hover:text-blue-600">${post.title}</a>
                            <p class="text-sm text-gray-500 mt-1">Status: 
                                <span class="px-2 py-1 rounded-full text-xs font-semibold ${statusColor}">${post.status}</span>
                            </p>
                        </div>
                        <a href="write.html?edit=${post.id}" class="text-sm font-semibold text-blue-600 hover:underline">Edit</a>
                    `;
                    myPostsContainer.appendChild(postElement);
                });
            } else {
                myPostsContainer.innerHTML = '<p class="text-gray-500">You have not written any posts yet.</p>';
            }
        };
        onAuthStateChange(user => {
            if (user) {
                loadProfileData(user);
                loadUserPosts(user);
            } else {
                window.location.href = 'login.html';
            }
        });
    }

    // --- Homepage Logic ---
    const recentPostsGrid = document.getElementById('recent-posts-grid');
    if (recentPostsGrid) {
        const displayFeaturedPost = async () => {
            const result = await getFeaturedPost();
            if (result.success) {
                const post = result.post;
                const featuredPostContainer = document.getElementById('featured-post');
                if (featuredPostContainer) {
                    featuredPostContainer.innerHTML = `
                        <div class="bg-white rounded-xl shadow-lg overflow-hidden lg:flex">
                            <div class="lg:w-1/2">
                                <a href="post.html?id=${post.id}"><img class="h-64 lg:h-full w-full object-cover" src="${post.photoUrl || 'https://placehold.co/800x600/002347/FFFFFF?text=Campus+View'}" alt="${post.title}"></a>
                            </div>
                            <div class="p-8 lg:p-12 lg:w-1/2 flex flex-col justify-center">
                                <p class="text-sm text-blue-500 font-semibold">Featured Article</p>
                                <a href="post.html?id=${post.id}"><h2 class="text-3xl font-bold mt-2 mb-4 hover:text-blue-600">${post.title}</h2></a>
                                <p class="text-gray-600 mb-6">${post.description || ''}</p>
                                <div class="flex items-center"><p class="font-semibold">${post.authorName}</p></div>
                            </div>
                        </div>`;
                }
            }
        };
        const displayApprovedPosts = async () => {
            const result = await getApprovedPosts();
            recentPostsGrid.innerHTML = '';
            if (result.success && result.posts.length > 0) {
                result.posts.forEach(post => {
                    if (post.isFeatured) return;
                    const postCard = document.createElement('div');
                    postCard.className = 'bg-white rounded-xl shadow-lg overflow-hidden transform hover:-translate-y-2 transition-transform duration-300';
                    const postDate = post.createdAt ? post.createdAt.toDate().toLocaleDateString() : 'N/A';
                    postCard.innerHTML = `
                        <a href="post.html?id=${post.id}"><img class="h-48 w-full object-cover" src="${post.photoUrl || 'https://placehold.co/600x400/E2E8F0/4A5568?text=GIKI+Blog'}" alt="${post.title}"></a>
                        <div class="p-6">
                            <p class="text-sm text-gray-500 mb-2">${postDate}</p>
                            <h4 class="text-xl font-semibold mb-3">${post.title}</h4>
                            <p class="text-gray-600 text-sm mb-4">${post.description || ''}</p>
                            <a href="post.html?id=${post.id}" class="font-semibold text-blue-600 hover:underline">Read More &rarr;</a>
                        </div>`;
                    recentPostsGrid.appendChild(postCard);
                });
            } else if (result.success) {
                recentPostsGrid.innerHTML = '<p class="text-gray-500">No posts have been approved yet.</p>';
            }
        };
        displayFeaturedPost();
        displayApprovedPosts();
    }

    // --- Single Post Page Logic ---
    if (document.getElementById('post-content')) {
        const displaySinglePost = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const postId = urlParams.get('id');
            if (!postId) {
                document.getElementById('post-title').textContent = 'Post not found!';
                return;
            }
            
            // Show loading state
            const postContent = document.getElementById('post-content');
            if (postContent) {
                postContent.innerHTML = '<div class="flex justify-center items-center py-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div></div>';
            }
            
            const result = await getPostById(postId);
            if (result.success) {
                const post = result.post;
                document.title = `${post.title} - GIKI Chronicles`;
                document.getElementById('post-title').textContent = post.title;
                const postDate = post.createdAt ? post.createdAt.toDate().toLocaleDateString() : 'N/A';
                document.getElementById('post-meta').textContent = `Posted by ${post.authorName} on ${postDate}`;
                if (post.photoUrl) {
                    document.getElementById('post-image').src = post.photoUrl;
                } else {
                    document.getElementById('post-image').style.display = 'none';
                }
                document.getElementById('post-content').innerHTML = post.content;
                
                // Apply theme-aware styles to the loaded content
                applyThemeToPostContent();
                
                // Load comments and reactions much later (after user has seen the post content)
                setTimeout(() => {
                    if (typeof initializeCommentsAndReactions === 'function') {
                        initializeCommentsAndReactions(postId);
                    } else {
                        console.warn('initializeCommentsAndReactions function not found');
                    }
                }, 2000); // 2 second delay - user can read the post content first
            } else {
                document.getElementById('post-title').textContent = 'Error';
            }
        };
        
        // Function to apply theme-aware styles to post content
        const applyThemeToPostContent = () => {
            const postContent = document.getElementById('post-content');
            if (!postContent) return;
            
            const currentTheme = localStorage.getItem('selected-theme') || 'basic-dark';
            const isDarkTheme = currentTheme === 'basic-dark';
            
            // Apply theme-aware styles to all text elements in the post content
            const textElements = postContent.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li, span, div, blockquote, code, pre, strong, em, a, ul, ol');
            
            textElements.forEach(element => {
                // Skip elements that already have explicit theme styles
                if (element.style.color && element.style.color.includes('var(--')) {
                    return;
                }
                
                if (isDarkTheme) {
                    // Apply dark theme styles
                    element.style.color = '#f9fafb'; // Light text for dark theme
                    
                    // Special handling for links
                    if (element.tagName === 'A') {
                        element.style.color = '#60a5fa'; // Blue for links in dark theme
                    }
                    
                    // Special handling for code blocks
                    if (element.tagName === 'CODE') {
                        element.style.backgroundColor = '#1f2937';
                        element.style.color = '#f9fafb';
                    }
                    
                    // Special handling for pre blocks
                    if (element.tagName === 'PRE') {
                        element.style.backgroundColor = '#1f2937';
                        element.style.color = '#f9fafb';
                    }
                    
                    // Special handling for blockquotes
                    if (element.tagName === 'BLOCKQUOTE') {
                        element.style.color = '#9ca3af';
                        element.style.borderLeftColor = '#4b5563';
                    }
                } else {
                    // Apply light theme styles
                    element.style.color = '#1f2937'; // Dark text for light theme
                    
                    // Special handling for links
                    if (element.tagName === 'A') {
                        element.style.color = '#2563eb'; // Blue for links in light theme
                    }
                    
                    // Special handling for code blocks
                    if (element.tagName === 'CODE') {
                        element.style.backgroundColor = '#f8f9fa';
                        element.style.color = '#1f2937';
                    }
                    
                    // Special handling for pre blocks
                    if (element.tagName === 'PRE') {
                        element.style.backgroundColor = '#f8f9fa';
                        element.style.color = '#1f2937';
                    }
                    
                    // Special handling for blockquotes
                    if (element.tagName === 'BLOCKQUOTE') {
                        element.style.color = '#6b7280';
                        element.style.borderLeftColor = '#e5e7eb';
                    }
                }
            });
        };
        
        // Make the function globally accessible for theme changes
        window.applyThemeToPostContent = applyThemeToPostContent;
        
        // Listen for theme changes
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            themeSelect.addEventListener('change', () => {
                // Wait a bit for the theme to be applied, then update post content
                setTimeout(() => {
                    applyThemeToPostContent();
                }, 100);
            });
        }
        
        // Set up mutation observer to handle dynamically added content
        const postContent = document.getElementById('post-content');
        if (postContent) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // New content was added, apply theme styles
                        setTimeout(() => {
                            applyThemeToPostContent();
                        }, 50);
                    }
                });
            });
            
            observer.observe(postContent, {
                childList: true,
                subtree: true
            });
        }
        
        // Also apply theme styles when the page loads (in case content is already there)
        setTimeout(() => {
            applyThemeToPostContent();
        }, 200);
        
        displaySinglePost();
    }

    // --- Contact Form Logic ---
    const contactForm = document.getElementById('contact-form');
    if (contactForm) {
        contactForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const formMessage = document.getElementById('form-message');
            formMessage.textContent = 'Sending...';
            const submissionData = {
                name: contactForm.name.value,
                email: contactForm.email.value,
                subject: contactForm.subject.value,
                message: contactForm.message.value
            };
            const result = await saveContactSubmission(submissionData);
            if (result.success) {
                formMessage.textContent = 'Message sent successfully!';
                formMessage.classList.add('text-green-500');
                contactForm.reset();
            } else {
                formMessage.textContent = result.error;
                formMessage.classList.add('text-red-500');
            }
        });
    }

    // Listen for custom auth state changed events (for cross-tab synchronization)
    window.addEventListener('authStateChanged', async (event) => {
        console.log("App.js: Custom auth state changed event received:", event.detail);
        const { user, initialized } = event.detail;
        
        if (initialized && user) {
            // Ensure user data is properly loaded when auth state is initialized
            if (typeof window.ensureUserDataLoaded === 'function') {
                try {
                    await window.ensureUserDataLoaded();
                } catch (error) {
                    console.error("App.js: Error ensuring user data loaded from custom event:", error);
                }
            }
        }
    });

    // --- Dynamic Navigation Bar & Logout Logic ---
    onAuthStateChange(async user => {
        console.log("App.js: Auth state changed, user:", user ? user.uid : "No user");
        
        const userNav = document.getElementById('user-nav');
        const guestNav = document.getElementById('guest-nav');
        const mobileUserNav = document.getElementById('mobile-user-nav');
        const mobileGuestNav = document.getElementById('mobile-guest-nav');
        const adminAccessBtn = document.getElementById('admin-access-btn');
        const mobileAdminAccessBtn = document.getElementById('mobile-admin-access-btn');
        
        if (user) {
            // Ensure user data is properly loaded
            if (typeof window.ensureUserDataLoaded === 'function') {
                try {
                    const dataLoaded = await window.ensureUserDataLoaded();
                    console.log("App.js: User data loaded:", dataLoaded);
                } catch (error) {
                    console.error("App.js: Error ensuring user data loaded:", error);
                }
            }
            
            if (userNav) userNav.style.display = 'flex';
            if (guestNav) guestNav.style.display = 'none';
            if (mobileUserNav) mobileUserNav.style.display = 'block';
            if (mobileGuestNav) mobileGuestNav.style.display = 'none';
            
            // Show user navigation in sidebar
            const sidebarUserNav = document.getElementById('sidebar-user-nav');
            const sidebarGuestNav = document.getElementById('sidebar-guest-nav');
            if (sidebarUserNav) sidebarUserNav.style.display = 'block';
            if (sidebarGuestNav) sidebarGuestNav.style.display = 'none';
            
            // Check if user is admin and show admin access button
            if (typeof checkUserAdminStatus === 'function') {
                try {
                    const isAdmin = await checkUserAdminStatus();
                    console.log("App.js: Admin status check result:", isAdmin);
                    if (isAdmin && adminAccessBtn) {
                        adminAccessBtn.style.display = 'inline-block';
                    }
                    if (isAdmin && mobileAdminAccessBtn) {
                        mobileAdminAccessBtn.style.display = 'block';
                    }
                    // Show sidebar admin button
                    const sidebarAdminBtn = document.getElementById('sidebar-admin-access-btn');
                    if (isAdmin && sidebarAdminBtn) {
                        sidebarAdminBtn.style.display = 'flex';
                    }
                } catch (error) {
                    console.error("App.js: Error checking admin status:", error);
                }
            }
        } else {
            if (userNav) userNav.style.display = 'none';
            if (guestNav) guestNav.style.display = 'flex';
            if (mobileUserNav) mobileUserNav.style.display = 'none';
            if (mobileGuestNav) mobileGuestNav.style.display = 'block';
            if (adminAccessBtn) adminAccessBtn.style.display = 'none';
            if (mobileAdminAccessBtn) mobileAdminAccessBtn.style.display = 'none';
            
            // Show guest navigation in sidebar
            const sidebarUserNav = document.getElementById('sidebar-user-nav');
            const sidebarGuestNav = document.getElementById('sidebar-guest-nav');
            if (sidebarUserNav) sidebarUserNav.style.display = 'none';
            if (sidebarGuestNav) sidebarGuestNav.style.display = 'block';
            
            // Hide sidebar admin button
            const sidebarAdminBtn = document.getElementById('sidebar-admin-access-btn');
            if (sidebarAdminBtn) sidebarAdminBtn.style.display = 'none';
        }
    });

    // Admin access button click handlers
    const adminAccessBtn = document.getElementById('admin-access-btn');
    if (adminAccessBtn) {
        adminAccessBtn.addEventListener('click', () => {
            window.location.href = 'admin-access.html';
        });
    }
    
    const mobileAdminAccessBtn = document.getElementById('mobile-admin-access-btn');
    if (mobileAdminAccessBtn) {
        mobileAdminAccessBtn.addEventListener('click', () => {
            window.location.href = 'admin-access.html';
        });
    }

    const sidebarAdminAccessBtn = document.getElementById('sidebar-admin-access-btn');
    if (sidebarAdminAccessBtn) {
        sidebarAdminAccessBtn.addEventListener('click', () => {
            window.location.href = 'admin-access.html';
        });
    }

    const logoutButton = document.getElementById('logout-button');
    if (logoutButton) {
        logoutButton.addEventListener('click', async () => {
            await logoutUser();
            window.location.href = 'index.html';
        });
    }
    const mobileLogoutButton = document.getElementById('mobile-logout-button');
    if (mobileLogoutButton) {
        mobileLogoutButton.addEventListener('click', async () => {
            await logoutUser();
            window.location.href = 'index.html';
        });
    }

    const sidebarLogoutButton = document.getElementById('sidebar-logout-button');
    if (sidebarLogoutButton) {
        sidebarLogoutButton.addEventListener('click', async () => {
            await logoutUser();
            window.location.href = 'index.html';
        });
    }
    // --- Gallery Page Logic ---
    const galleryGrid = document.getElementById('gallery-grid');
    if (galleryGrid) {
        const highlightedPhotoSection = document.getElementById('highlighted-photo');
        const categoryFilter = document.getElementById('category-filter');
        const openModalBtn = document.getElementById('open-submission-modal');
        const closeModalBtn = document.getElementById('close-modal');
        const submissionModal = document.getElementById('submission-modal');
        const submissionForm = document.getElementById('submission-form');
        const formMessage = document.getElementById('form-message');



        let allPhotos = [];

        const renderGallery = (photos) => {
            galleryGrid.innerHTML = '';
            if (photos.length === 0) {
                galleryGrid.innerHTML = `<p class="text-gray-500">No photos found for this category.</p>`;
                return;
            }
            photos.forEach(photo => {
                const photoCard = document.createElement('div');
                photoCard.className = 'bg-white rounded-xl shadow-lg overflow-hidden cursor-pointer transform hover:scale-105 transition-transform duration-200';
                photoCard.innerHTML = `
                     <div class="relative bg-gray-100 flex items-center justify-center" style="height: 280px;">
                         <img src="${photo.imageUrl}" alt="${photo.caption}" class="max-w-full max-h-full object-contain" loading="lazy" data-fullsize="${photo.fullSizeUrl || photo.imageUrl}">
                     </div>
                     <div class="p-4">
                         <p class="font-semibold mb-2">${photo.caption}</p>
                         <p class="text-sm text-gray-500">${photo.category}</p>
                         <p class="text-xs text-gray-400">By ${photo.uploaderName}</p>
                     </div>
                 `;

                // Add click event for fullscreen view
                photoCard.addEventListener('click', () => {
                    openFullscreenView(photo);
                });

                galleryGrid.appendChild(photoCard);
            });
        };

        let currentSlideIndex = 0;
        let slideshowInterval;

        const loadPhotos = async () => {
            const result = await getGalleryPhotos();
            if (result.success) {
                allPhotos = result.photos;
                renderGallery(allPhotos);
                loadHighlightedSlideshow();
            }
        };

        const loadHighlightedSlideshow = async () => {
            const result = await getHighlightedPhotos();
            if (result.success && result.photos.length > 0) {
                const highlightedPhotos = result.photos;

                // Clear existing interval
                if (slideshowInterval) {
                    clearInterval(slideshowInterval);
                }

                // Function to show current slide
                const showSlide = (index) => {
                    const photo = highlightedPhotos[index];
                    highlightedPhotoSection.innerHTML = `
                        <div class="relative">
                            <div class="cursor-pointer transform hover:scale-105 transition-transform duration-200" onclick="openFullscreenView(${JSON.stringify(photo)})">
                                <div class="bg-gray-100 flex items-center justify-center rounded-xl" style="height: 400px;">
                                    <img src="${photo.imageUrl}" alt="${photo.caption}" class="max-w-full max-h-full object-contain rounded-xl">
                                </div>
                                ${highlightedPhotos.length > 1 ? `
                                    <div class="absolute top-4 right-4 flex space-x-2">
                                        ${highlightedPhotos.map((_, i) => `
                                            <div class="w-3 h-3 rounded-full ${i === index ? 'bg-white' : 'bg-white bg-opacity-50'}"></div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <div class="mt-4 text-center">
                                <h3 class="text-2xl font-bold text-gray-800 mb-2">${photo.caption}</h3>
                                <p class="text-lg text-gray-600">${photo.category}</p>
                                <p class="text-sm text-gray-500 mt-1">By ${photo.uploaderName}</p>
                            </div>
                        </div>
                    `;
                };

                // Show first slide
                showSlide(0);

                // Auto-advance slideshow every 5 seconds if multiple photos
                if (highlightedPhotos.length > 1) {
                    slideshowInterval = setInterval(() => {
                        currentSlideIndex = (currentSlideIndex + 1) % highlightedPhotos.length;
                        showSlide(currentSlideIndex);
                    }, 5000);
                }
            } else {
                // Show first photo as fallback if no highlighted photos
                if (allPhotos.length > 0) {
                    highlightedPhotoSection.innerHTML = `
                        <div class="relative">
                            <div class="cursor-pointer transform hover:scale-105 transition-transform duration-200" onclick="openFullscreenView(${JSON.stringify(allPhotos[0])})">
                                <div class="bg-gray-100 flex items-center justify-center rounded-xl" style="height: 400px;">
                                    <img src="${allPhotos[0].imageUrl}" alt="${allPhotos[0].caption}" class="max-w-full max-h-full object-contain rounded-xl">
                                </div>
                            </div>
                            <div class="mt-4 text-center">
                                <h3 class="text-2xl font-bold text-gray-800 mb-2">${allPhotos[0].caption}</h3>
                                <p class="text-lg text-gray-600">${allPhotos[0].category}</p>
                                <p class="text-sm text-gray-500 mt-1">By ${allPhotos[0].uploaderName}</p>
                            </div>
                        </div>
                    `;
                }
            }
        };



        categoryFilter.addEventListener('change', () => {
            const category = categoryFilter.value;
            if (category === 'all') {
                renderGallery(allPhotos);
            } else {
                const filteredPhotos = allPhotos.filter(p => p.category === category);
                renderGallery(filteredPhotos);
            }
        });

        openModalBtn.addEventListener('click', () => submissionModal.classList.remove('hidden'));
        closeModalBtn.addEventListener('click', () => submissionModal.classList.add('hidden'));



        submissionForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitButton = submissionForm.querySelector('button[type="submit"]');
            const originalButtonText = submitButton.textContent;

            // Disable form and show loading state
            submitButton.disabled = true;
            submitButton.textContent = 'Uploading...';
            formMessage.textContent = 'Uploading...';

            const caption = document.getElementById('caption').value;
            const category = document.getElementById('photo-category').value;
            const file = document.getElementById('photo-upload').files[0];

            if (!file) {
                formMessage.textContent = 'Please select a photo.';
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
                return;
            }

            if (!category) {
                formMessage.textContent = 'Please select a category.';
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
                return;
            }

            // Check file size (10MB limit)
            const maxSize = 10 * 1024 * 1024; // 10MB in bytes
            if (file.size > maxSize) {
                formMessage.textContent = 'File is too large. Please select an image under 10MB.';
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
                return;
            }

            try {
                const result = await submitPhotoForReview(caption, category, file);
                if (result.success) {
                    formMessage.textContent = 'Photo added to gallery!';
                    submitButton.textContent = 'Success!';
                    setTimeout(() => {
                        submissionModal.classList.add('hidden');
                        formMessage.textContent = '';
                        submissionForm.reset();
                        submitButton.disabled = false;
                        submitButton.textContent = originalButtonText;
                        loadPhotos(); // Refresh the gallery to show the new photo
                    }, 2000);
                } else {
                    formMessage.textContent = result.error;
                    submitButton.disabled = false;
                    submitButton.textContent = originalButtonText;
                }
            } catch (error) {
                console.error('Upload error:', error);
                formMessage.textContent = 'Upload failed. Please try again.';
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
            }
        });



        loadPhotos();
    }

    // Fullscreen view function
    window.openFullscreenView = function (photo) {
        const fullscreenModal = document.createElement('div');
        fullscreenModal.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4 cursor-pointer';
        fullscreenModal.innerHTML = `
            <div class="relative w-full h-full flex items-center justify-center pointer-events-none">
                <button onclick="this.parentElement.parentElement.remove()" class="absolute top-4 right-4 text-white bg-black bg-opacity-60 hover:bg-opacity-80 rounded-full w-12 h-12 flex items-center justify-center transition-all duration-200 transform hover:scale-110 shadow-lg backdrop-blur-sm z-10 pointer-events-auto">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                <img src="${photo.fullSizeUrl || photo.imageUrl}" alt="${photo.caption}" class="max-w-full max-h-full object-contain pointer-events-auto" style="max-height: calc(100vh - 2rem);">
            </div>
        `;

        // Close on background click
        fullscreenModal.addEventListener('click', (e) => {
            if (e.target === fullscreenModal) {
                fullscreenModal.remove();
            }
        });

        // Close on escape key
        document.addEventListener('keydown', function closeOnEscape(e) {
            if (e.key === 'Escape') {
                fullscreenModal.remove();
                document.removeEventListener('keydown', closeOnEscape);
            }
        });

        document.body.appendChild(fullscreenModal);
    };

    // Toggle highlight function
    window.toggleHighlight = async function (photoId, isHighlighted) {
        const result = await togglePhotoHighlight(photoId, isHighlighted);
        if (result.success) {
            // Reload photos to update the UI
            loadPhotos();
        } else {
            alert('Failed to update photo status. Please try again.');
        }
    };
    // --- Admin Page Logic ---
    const adminContent = document.getElementById('admin-content');
    if (adminContent) {
        const loadingMessage = document.getElementById('loading-message');
        const postsContainer = document.getElementById('posts-container');
        const refreshPostsBtn = document.getElementById('refresh-posts-btn');
        
        // Tab management
        let currentTab = 'all';
        const tabButtons = {
            'all': document.getElementById('tab-all'),
            'pending': document.getElementById('tab-pending'),
            'approved': document.getElementById('tab-approved'),
            'rejected': document.getElementById('tab-rejected')
        };

        // Initialize tab functionality
        Object.keys(tabButtons).forEach(tab => {
            if (tabButtons[tab]) {
                tabButtons[tab].addEventListener('click', () => {
                    currentTab = tab;
                    updateTabStyles();
                    displayPosts();
                });
            }
        });

        function updateTabStyles() {
            Object.keys(tabButtons).forEach(tab => {
                if (tabButtons[tab]) {
                    if (tab === currentTab) {
                        tabButtons[tab].className = 'tab-btn px-4 py-2 rounded-md font-medium transition-colors bg-blue-500 text-white';
                    } else {
                        tabButtons[tab].className = 'tab-btn px-4 py-2 rounded-md font-medium transition-colors text-gray-700 hover:bg-white';
                    }
                }
            });
        }

        // Refresh button functionality
        if (refreshPostsBtn) {
            refreshPostsBtn.addEventListener('click', () => {
                displayPosts();
            });
        }

        const displayPosts = async () => {
            console.log("Fetching posts for tab:", currentTab);
            const result = await getAllPosts(currentTab);
            console.log("Posts result:", result);
            
            if (postsContainer) {
                postsContainer.innerHTML = ''; // Clear loader

                if (result.success && result.posts.length > 0) {
                    console.log("Displaying", result.posts.length, "posts");
                    result.posts.forEach(post => {
                        const postElement = createPostElement(post);
                        postsContainer.appendChild(postElement);
                    });
                } else {
                    console.log("No posts or error:", result.error);
                    const statusText = currentTab === 'all' ? 'posts' : currentTab + ' posts';
                    postsContainer.innerHTML = `<p class="text-gray-500">No ${statusText} found.</p>`;
                }
            }
        };

        function createPostElement(post) {
            const postElement = document.createElement('div');
            postElement.className = 'flex justify-between items-center p-4 border rounded-lg bg-white hover:bg-gray-50 transition-colors';
            
            const postDate = post.createdAt ? post.createdAt.toDate().toLocaleDateString() : 'N/A';
            let statusColor = 'bg-yellow-200 text-yellow-800';
            if (post.status === 'approved') {
                statusColor = 'bg-green-200 text-green-800';
            } else if (post.status === 'rejected') {
                statusColor = 'bg-red-200 text-red-800';
            }

            postElement.innerHTML = `
                <div class="flex-1">
                    <div class="flex items-center space-x-3">
                        <h3 class="font-bold text-lg">${post.title}</h3>
                        <span class="px-2 py-1 rounded-full text-xs font-semibold ${statusColor}">${post.status}</span>
                    </div>
                    <p class="text-sm text-gray-500 mt-1">By: ${post.authorName} • ${postDate}</p>
                    <p class="text-sm text-gray-600 mt-1">${post.description || 'No description'}</p>
                </div>
                <div class="flex space-x-2">
                    <button data-id="${post.id}" class="view-btn bg-blue-500 text-white px-3 py-1 rounded-full text-sm font-semibold hover:bg-blue-600">View</button>
                    ${post.status === 'pending' ? `
                        <button data-id="${post.id}" class="approve-btn bg-green-500 text-white px-3 py-1 rounded-full text-sm font-semibold hover:bg-green-600">Approve</button>
                        <button data-id="${post.id}" class="reject-btn bg-red-500 text-white px-3 py-1 rounded-full text-sm font-semibold hover:bg-red-600">Reject</button>
                    ` : ''}
                    <button data-id="${post.id}" class="delete-btn bg-red-600 text-white px-3 py-1 rounded-full text-sm font-semibold hover:bg-red-700">Delete</button>
                </div>
            `;

            // Add event listeners
            const viewBtn = postElement.querySelector('.view-btn');
            if (viewBtn) {
                viewBtn.addEventListener('click', () => viewPost(post));
            }

            const approveBtn = postElement.querySelector('.approve-btn');
            if (approveBtn) {
                approveBtn.addEventListener('click', async (e) => {
                    const postId = e.target.dataset.id;
                    await updatePostStatus(postId, 'approved');
                    displayPosts(); // Refresh the list
                });
            }

            const rejectBtn = postElement.querySelector('.reject-btn');
            if (rejectBtn) {
                rejectBtn.addEventListener('click', async (e) => {
                    const postId = e.target.dataset.id;
                    await updatePostStatus(postId, 'rejected');
                    displayPosts(); // Refresh the list
                });
            }

            const deleteBtn = postElement.querySelector('.delete-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    const postId = e.target.dataset.id;
                    showDeleteConfirmation(postId, post.title);
                });
            }

            return postElement;
        }

        function viewPost(post) {
            const modal = document.getElementById('post-content-modal');
            const modalContent = document.getElementById('modal-post-content');
            const modalApproveBtn = document.getElementById('modal-approve-btn');
            const modalRejectBtn = document.getElementById('modal-reject-btn');

            if (modal && modalContent) {
                modalContent.innerHTML = `
                    <h1 class="text-3xl font-bold mb-4">${post.title}</h1>
                    <div class="text-sm text-gray-500 mb-4">
                        By ${post.authorName} • ${post.createdAt ? post.createdAt.toDate().toLocaleDateString() : 'N/A'}
                    </div>
                    <div class="prose max-w-none">
                        ${post.content}
                    </div>
                `;

                // Update modal buttons based on post status
                if (modalApproveBtn && modalRejectBtn) {
                    if (post.status === 'pending') {
                        modalApproveBtn.style.display = 'inline-block';
                        modalRejectBtn.style.display = 'inline-block';
                        modalApproveBtn.onclick = () => {
                            updatePostStatus(post.id, 'approved');
                            modal.classList.add('hidden');
                            displayPosts();
                        };
                        modalRejectBtn.onclick = () => {
                            updatePostStatus(post.id, 'rejected');
                            modal.classList.add('hidden');
                            displayPosts();
                        };
                    } else {
                        modalApproveBtn.style.display = 'none';
                        modalRejectBtn.style.display = 'none';
                    }
                }

                modal.classList.remove('hidden');
            }
        }

        function showDeleteConfirmation(postId, postTitle) {
            const modal = document.getElementById('delete-confirmation-modal');
            const postIdSpan = document.getElementById('delete-post-id');
            const confirmBtn = document.getElementById('confirm-delete-btn');
            const cancelBtn = document.getElementById('cancel-delete-btn');

            if (modal && postIdSpan && confirmBtn && cancelBtn) {
                postIdSpan.textContent = postId;
                
                confirmBtn.onclick = async () => {
                    const result = await deletePostPermanently(postId);
                    if (result.success) {
                        modal.classList.add('hidden');
                        displayPosts(); // Refresh the list
                    } else {
                        alert('Error deleting post: ' + result.error);
                    }
                };

                cancelBtn.onclick = () => {
                    modal.classList.add('hidden');
                };

                modal.classList.remove('hidden');
            }
        }

        // Close modal functions
        window.closePostModal = function() {
            const modal = document.getElementById('post-content-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };

        // Close delete modal when clicking outside
        const deleteModal = document.getElementById('delete-confirmation-modal');
        if (deleteModal) {
            deleteModal.addEventListener('click', (e) => {
                if (e.target === deleteModal) {
                    deleteModal.classList.add('hidden');
                }
            });
        }

        // Close post modal when clicking outside
        const postModal = document.getElementById('post-content-modal');
        if (postModal) {
            postModal.addEventListener('click', (e) => {
                if (e.target === postModal) {
                    postModal.classList.add('hidden');
                }
            });
        }

        const checkAdminAndLoad = async () => {
            console.log("Checking admin status...");
            
            // Check for secure access first
            const hasSecureAccess = checkSecureAdminAccess();
            console.log("Secure access check:", hasSecureAccess);
            
            if (hasSecureAccess) {
                console.log("✅ Secure admin access granted");
                loadingMessage.style.display = 'none';
                adminContent.style.display = 'block';
                displayPosts();
                displayPendingEvents();
                displayPendingGalleryPhotos();
                return;
            }
            
            // TEMPORARY: Force admin access for testing
            const forceAdmin = false; // Set this to false to restore normal admin checking
            
            if (forceAdmin) {
                console.log("🔧 TEMPORARY: Bypassing admin check for testing");
                loadingMessage.style.display = 'none';
                adminContent.style.display = 'block';
                displayPosts();
                displayPendingEvents();
                displayPendingGalleryPhotos();
                return;
            }
            
            // Try the simple test first
            const testResult = await testAdminStatus();
            console.log("Test admin result:", testResult);
            
            const isAdmin = typeof checkUserAdminStatus === 'function' ? await checkUserAdminStatus() : false;
            console.log("Admin status result:", isAdmin);
            
            if (isAdmin) {
                console.log("Admin access granted, loading dashboard...");
                loadingMessage.style.display = 'none';
                adminContent.style.display = 'block';
                displayPosts();
                displayPendingEvents();
                displayPendingGalleryPhotos();
            } else {
                console.log("Admin access denied");
                loadingMessage.innerHTML = '<p class="text-lg text-red-500">Access Denied. You must be an administrator to view this page.</p>';
            }
        };

        onAuthStateChange(user => {
            if (user) {
                checkAdminAndLoad();
            } else {
                // If no user is logged in, redirect to the login page
                window.location.href = 'login.html';
            }
        });
    }
    const displayApprovedPostsAdmin = async () => {
        const result = await getApprovedPosts();
        approvedPostsContainer.innerHTML = ''; // Clear loader

        if (result.success && result.posts.length > 0) {
            result.posts.forEach(post => {
                const postElement = document.createElement('div');
                postElement.className = 'flex justify-between items-center p-4 border rounded-lg bg-white';

                const featureButtonText = post.isFeatured ? 'Unfeature' : 'Feature';
                const featureButtonClass = post.isFeatured ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-blue-500 hover:bg-blue-600';

                postElement.innerHTML = `
                        <div>
                            <p class="font-bold text-lg">${post.title}</p>
                            <p class="text-sm text-gray-500">By: ${post.authorName}</p>
                        </div>
                        <div class="flex space-x-2">
                            <button data-id="${post.id}" data-featured="${post.isFeatured}" class="feature-btn ${featureButtonClass} text-white px-3 py-1 rounded-full text-sm font-semibold">${featureButtonText}</button>
                        </div>
                    `;
                approvedPostsContainer.appendChild(postElement);
            });
        } else {
            approvedPostsContainer.innerHTML = '<p class="text-gray-500">There are no approved posts to feature.</p>';
        }

        // Add event listeners to the new feature buttons
        document.querySelectorAll('.feature-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const postId = e.target.dataset.id;
                const isCurrentlyFeatured = e.target.dataset.featured === 'true';
                await toggleFeaturedStatus(postId, !isCurrentlyFeatured);
                displayApprovedPostsAdmin(); // Refresh the list
            });
        });
    };

    // Display pending events for admin review
    const displayPendingEvents = async () => {
        const pendingEventsContainer = document.getElementById('pending-events-container');
        if (!pendingEventsContainer) {
            console.error('Pending events container not found');
            return;
        }

        try {
            const result = await getPendingEvents();
            
            if (result.success && result.events && result.events.length > 0) {
                pendingEventsContainer.innerHTML = '';
                
                result.events.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.className = 'bg-white border rounded-lg p-4 shadow-sm';
                    
                    const eventDate = event.date ? new Date(event.date).toLocaleDateString() : 'No date';
                    const eventTime = event.time || 'No time';
                    
                    eventElement.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div class="flex-1">
                                <h3 class="font-bold text-lg text-gray-800">${event.name}</h3>
                                <p class="text-sm text-gray-600 mt-1">${event.description}</p>
                                <div class="flex items-center space-x-4 mt-2 text-sm text-gray-500">
                                    <span>📅 ${eventDate}</span>
                                    <span>🕒 ${eventTime}</span>
                                    <span>📍 ${event.location || 'No location'}</span>
                                </div>
                                <p class="text-xs text-gray-400 mt-2">Submitted by: ${event.submittedBy || 'Unknown'}</p>
                            </div>
                            <div class="flex space-x-2 ml-4">
                                <button onclick="approveEvent('${event.id}')" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                    Approve
                                </button>
                                <button onclick="rejectEvent('${event.id}')" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                    Reject
                                </button>
                            </div>
                        </div>
                    `;
                    
                    pendingEventsContainer.appendChild(eventElement);
                });
            } else {
                pendingEventsContainer.innerHTML = '<p class="text-gray-500">No pending events to review.</p>';
            }
        } catch (error) {
            console.error('Error loading pending events:', error);
            pendingEventsContainer.innerHTML = '<p class="text-red-500">Error loading pending events.</p>';
        }
    };

    // Display pending gallery photos for admin review
    const displayPendingGalleryPhotos = async () => {
        const pendingGalleryContainer = document.getElementById('pending-gallery-container');
        if (!pendingGalleryContainer) {
            console.log('Pending gallery container not found - not on admin page or element removed');
            return;
        }

        try {
            const result = await getPendingGalleryPhotos();
            
            if (result.success && result.photos && result.photos.length > 0) {
                pendingGalleryContainer.innerHTML = '';
                
                result.photos.forEach(photo => {
                    const photoElement = document.createElement('div');
                    photoElement.className = 'bg-white border rounded-lg p-4 shadow-sm';
                    
                    photoElement.innerHTML = `
                        <div class="flex items-start space-x-4">
                            <div class="flex-shrink-0">
                                <img src="${photo.imageUrl}" alt="${photo.caption}" class="w-24 h-24 object-cover rounded-lg">
                            </div>
                            <div class="flex-1">
                                <h3 class="font-bold text-lg text-gray-800">${photo.caption}</h3>
                                <p class="text-sm text-gray-600 mt-1">Category: ${photo.category}</p>
                                <p class="text-xs text-gray-400 mt-2">Submitted by: ${photo.uploaderName || 'Unknown'}</p>
                                <p class="text-xs text-gray-400">Uploaded: ${photo.createdAt ? new Date(photo.createdAt.toDate ? photo.createdAt.toDate() : photo.createdAt).toLocaleDateString() : 'Unknown'}</p>
                            </div>
                            <div class="flex flex-col space-y-2">
                                <button onclick="approveGalleryPhoto('${photo.id}')" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                    Approve
                                </button>
                                <button onclick="rejectGalleryPhoto('${photo.id}')" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm font-medium transition-colors">
                                    Reject
                                </button>
                            </div>
                        </div>
                    `;
                    
                    pendingGalleryContainer.appendChild(photoElement);
                });
            } else {
                pendingGalleryContainer.innerHTML = '<p class="text-gray-500">No pending gallery photos to review.</p>';
            }
        } catch (error) {
            console.error('Error loading pending gallery photos:', error);
            pendingGalleryContainer.innerHTML = '<p class="text-red-500">Error loading pending gallery photos.</p>';
        }
    };

    // Event approval functions
    window.approveEvent = async (eventId) => {
        try {
            const result = await updateEventStatus(eventId, 'approved');
            if (result.success) {
                displayPendingEvents(); // Refresh the list
            } else {
                alert('Error approving event: ' + result.error);
            }
        } catch (error) {
            console.error('Error approving event:', error);
            alert('Error approving event');
        }
    };

    window.rejectEvent = async (eventId) => {
        try {
            const result = await updateEventStatus(eventId, 'rejected');
            if (result.success) {
                displayPendingEvents(); // Refresh the list
            } else {
                alert('Error rejecting event: ' + result.error);
            }
        } catch (error) {
            console.error('Error rejecting event:', error);
            alert('Error rejecting event');
        }
    };

    // Gallery photo approval functions
    window.approveGalleryPhoto = async (photoId) => {
        try {
            const result = await updateGalleryPhotoStatus(photoId, 'approved');
            if (result.success) {
                displayPendingGalleryPhotos(); // Refresh the list
            } else {
                alert('Error approving photo: ' + result.error);
            }
        } catch (error) {
            console.error('Error approving photo:', error);
            alert('Error approving photo');
        }
    };

    window.rejectGalleryPhoto = async (photoId) => {
        try {
            const result = await updateGalleryPhotoStatus(photoId, 'rejected');
            if (result.success) {
                displayPendingGalleryPhotos(); // Refresh the list
            } else {
                alert('Error rejecting photo: ' + result.error);
            }
        } catch (error) {
            console.error('Error rejecting photo:', error);
            alert('Error rejecting photo');
        }
    };
});


// theme-manager.js
// Theme Management for GIKI Chronicles
// This file handles theme switching across all pages

// Load saved theme from localStorage, default to 'basic-dark' (black theme)
let savedTheme = localStorage.getItem('selected-theme');
if (!savedTheme) {
    savedTheme = 'basic-dark';
    localStorage.setItem('selected-theme', savedTheme);
}

// Function to apply theme
function applyTheme(themeName) {
    console.log('Applying theme:', themeName);
    
    // Remove all existing theme classes from both html and body
    document.documentElement.classList.remove('theme-basic-light', 'theme-basic-dark', 'theme-giki');
    document.body.classList.remove('theme-basic-light', 'theme-basic-dark', 'theme-giki');
    
    // Add the selected theme class to both html and body
    document.documentElement.classList.add(`theme-${themeName}`);
    document.body.classList.add(`theme-${themeName}`);
    
    // Save the theme to localStorage
    localStorage.setItem('selected-theme', themeName);
    
    // Update theme selector if it exists
    const themeSelect = document.getElementById('theme-select');
    if (themeSelect) {
        themeSelect.value = themeName;
    }
    
    console.log('Theme applied successfully. Current classes:', document.body.className);
}

// Function to initialize theme functionality
function initializeTheme() {
    // Apply the saved theme immediately
    applyTheme(savedTheme);

    // Set up event listener for theme selector
    const themeSelect = document.getElementById('theme-select');
    if (themeSelect) {
        // Set the current value
        themeSelect.value = savedTheme;
        
        // Add event listener for theme selector
        themeSelect.addEventListener('change', function() {
            const selectedTheme = this.value;
            applyTheme(selectedTheme);
        });
    }
}

// Initialize theme as soon as possible
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeTheme);
} else {
    // If DOM is already loaded, initialize immediately
    initializeTheme();
}

// Also apply theme immediately for faster visual feedback
applyTheme(savedTheme);

// Additional fallback to ensure theme is applied
setTimeout(() => {
    if (!document.body.classList.contains(`theme-${savedTheme}`)) {
        applyTheme(savedTheme);
    }
}, 100); 

// posts.js
/**
 * posts.js
 * This file contains the core functions for interacting with the 'posts'
 * collection in the Firestore database.
 */

/*
    FIRESTORE DATABASE STRUCTURE for the 'posts' collection:
    - title (string)
    - content (string)
    - description (string)
    - photoUrl (string)
    - authorId (string)
    - authorName (string)
    - createdAt (timestamp)
    - status (string): "pending", "approved", "rejected"
    - genre (string)
    - tags (array)
    - isFeatured (boolean, optional): Set to true for the featured post.
*/

async function createPost(postData) {
    console.log("createPost called with data:", postData);
    const user = auth.currentUser;
    if (!user) {
        console.error("No user is logged in.");
        return { success: false, error: "You must be logged in to create a post." };
    }

    console.log("User authenticated:", user.uid, user.email);

    try {
        // Convert the comma-separated tags string into an array of strings.
        const tagsArray = postData.tags ? postData.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        console.log("Tags array:", tagsArray);

        const newPost = {
            title: postData.title,
            content: postData.content,
            description: postData.description || "",
            photoUrl: postData.photoUrl || "",
            genre: postData.genre || "General",
            tags: tagsArray,
            authorId: user.uid,
            authorName: user.displayName || user.email,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            status: "pending",
            isFeatured: false // Default to not featured
        };

        console.log("Prepared post data:", newPost);
        console.log("Attempting to add to Firestore...");

        const docRef = await db.collection("posts").add(newPost);
        console.log("Post created successfully with ID:", docRef.id);
        
        // Note: Stats will be updated when the post is approved by admin
        // We don't update stats for pending posts to keep counts accurate
        
        return { success: true, postId: docRef.id };

    } catch (error) {
        console.error("Error creating post:", error);
        console.error("Error details:", error.message, error.code);
        return { success: false, error: "Failed to create post: " + error.message };
    }
}

/**
 * Fetches all blog posts from Firestore that have been approved.
 */
async function getApprovedPosts() {
    try {
        const snapshot = await db.collection("posts")
            .where("status", "==", "approved")
            .orderBy("createdAt", "desc") // Show the newest posts first
            .get();

        if (snapshot.empty) {
            console.log("No approved posts found.");
            return { success: true, posts: [] };
        }

        const posts = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        return { success: true, posts: posts };

    } catch (error) {
        console.error("Error fetching approved posts:", error);
        return { success: false, error: "Failed to fetch posts." };
    }
}

/**
 * Fetches a single blog post from Firestore using its document ID.
 */
async function getPostById(postId) {
    try {
        const docRef = db.collection("posts").doc(postId);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            return { success: true, post: { id: docSnap.id, ...docSnap.data() } };
        } else {
            console.error("No such document!");
            return { success: false, error: "Post not found." };
        }
    } catch (error) {
        console.error("Error fetching post by ID:", error);
        return { success: false, error: "Failed to fetch post." };
    }
}

/**
 * Fetches the single post marked as featured.
 * @returns {Promise<object>} A promise that resolves with the featured post object.
 */
async function getFeaturedPost() {
    try {
        const snapshot = await db.collection("posts")
            .where("isFeatured", "==", true)
            .where("status", "==", "approved")
            .limit(1)
            .get();

        if (snapshot.empty) {
            return { success: false, error: "No featured post found." };
        }

        const post = { id: snapshot.docs[0].id, ...snapshot.docs[0].data() };
        return { success: true, post: post };

    } catch (error) {
        console.error("Error fetching featured post:", error);
        return { success: false, error: "Failed to fetch post." };
    }
}

/**
 * Fetches all posts written by a specific author.
 * @param {string} authorId - The UID of the author.
 * @returns {Promise<object>} A promise that resolves with an array of the author's posts.
 */
async function getPostsByAuthor(authorId) {
    try {
        const snapshot = await db.collection("posts")
            .where("authorId", "==", authorId)
            .orderBy("createdAt", "desc")
            .get();

        const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        return { success: true, posts: posts };

    } catch (error) {
        console.error("Error fetching posts by author:", error);
        return { success: false, error: "Failed to fetch posts." };
    }
}
/**
 * Fetches a post for editing, ensuring the current user is the author.
 * @param {string} postId - The ID of the post to fetch.
 * @returns {Promise<object>}
 */
async function getPostForEditing(postId) {
    console.log("getPostForEditing called with postId:", postId); // DEBUG

    const user = auth.currentUser;
    console.log("Current user in getPostForEditing:", user ? user.uid : "Not logged in"); // DEBUG

    if (!user) return { success: false, error: "Authentication required." };

    try {
        console.log("Attempting to fetch document from Firestore..."); // DEBUG
        const docRef = db.collection("posts").doc(postId);
        const docSnap = await docRef.get();

        console.log("Document exists:", docSnap.exists); // DEBUG

        if (!docSnap.exists) return { success: false, error: "Post not found." };

        const post = docSnap.data();
        console.log("Post data retrieved:", post); // DEBUG
        console.log("Post authorId:", post.authorId); // DEBUG
        console.log("Current user UID:", user.uid); // DEBUG

        // Security check: ensure the person editing is the original author.
        if (post.authorId !== user.uid) {
            console.log("Authorization failed - user not the author"); // DEBUG
            return { success: false, error: "You are not authorized to edit this post." };
        }

        console.log("Authorization successful, returning post data"); // DEBUG
        return { success: true, post: { id: docSnap.id, ...post } };
    } catch (error) {
        console.error("Error fetching post for editing:", error);
        return { success: false, error: "Failed to fetch post." };
    }
}

/**
 * Updates an existing post in Firestore.
 * @param {string} postId - The ID of the post to update.
 * @param {object} postData - An object containing the updated data.
 * @returns {Promise<object>}
 */
async function updatePost(postId, postData) {
    const user = auth.currentUser;
    if (!user) return { success: false, error: "Authentication required." };

    try {
        const tagsArray = postData.tags ? postData.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

        const updatedPost = {
            title: postData.title,
            content: postData.content,
            description: postData.description || "",
            photoUrl: postData.photoUrl || "",
            genre: postData.genre || "General",
            tags: tagsArray,
            status: "pending" // Reset status to pending for re-approval
        };

        const docRef = db.collection("posts").doc(postId);
        await docRef.update(updatedPost);

        return { success: true };
    } catch (error) {
        console.error("Error updating post:", error);
        return { success: false, error: "Failed to update post." };
    }
}
async function savePostAsDraft(postData, postId = null) {
    const user = auth.currentUser;
    if (!user) return { success: false, error: "Authentication required." };

    try {
        const tagsArray = postData.tags ? postData.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        const draftData = {
            title: postData.title,
            content: postData.content,
            description: postData.description || "",
            photoUrl: postData.photoUrl || "",
            genre: postData.genre || "General",
            tags: tagsArray,
            authorId: user.uid,
            authorName: user.displayName || user.email,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            status: "draft" // Set status to draft
        };

        if (postId) {
            // Update the existing draft
            const docRef = db.collection("posts").doc(postId);
            await docRef.update(draftData);
            return { success: true, postId: postId };
        } else {
            // Create a new draft
            const docRef = await db.collection("posts").add(draftData);
            return { success: true, postId: docRef.id };
        }
    } catch (error) {
        console.error("Error saving draft:", error);
        return { success: false, error: "Failed to save draft." };
    }
}
/**
 * Fetches all posts that are awaiting admin review.
 * @returns {Promise<object>} A promise that resolves with an array of pending post objects.
 */
async function getPendingPosts() {
    const user = auth.currentUser;
    if (!user) {
        console.log("No authenticated user");
        return { success: false, error: "Authentication required." };
    }

    console.log("Getting pending posts for user:", user.uid);

    // Verify admin status server-side
    try {
        console.log("Checking admin status...");
        const isAdmin = await isUserAdmin();
        console.log("Admin check result:", isAdmin);
        
        if (!isAdmin) {
            console.error("Unauthorized access attempt to fetch pending posts");
            return { success: false, error: "Admin privileges required." };
        }

        console.log("Admin verified, fetching pending posts...");
        const snapshot = await db.collection("posts")
            .where("status", "==", "pending")
            .orderBy("createdAt", "asc") // Show oldest submissions first
            .get();

        const posts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        console.log("Found", posts.length, "pending posts");
        return { success: true, posts: posts };

    } catch (error) {
        console.error("Error fetching pending posts:", error);
        return { success: false, error: "Failed to fetch pending posts." };
    }
}

/**
 * Updates the status of a post (e.g., to "approved" or "rejected").
 * @param {string} postId - The ID of the post to update.
 * @param {string} newStatus - The new status ("approved" or "rejected").
 * @returns {Promise<object>} A promise that resolves on success.
 */
async function updatePostStatus(postId, newStatus) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "Authentication required." };
    }

    // Verify admin status server-side
    try {
        const isAdmin = await isUserAdmin();
        if (!isAdmin) {
            console.error("Unauthorized access attempt to update post status");
            return { success: false, error: "Admin privileges required." };
        }

        const docRef = db.collection("posts").doc(postId);
        await docRef.update({ 
            status: newStatus,
            reviewedBy: user.uid,
            reviewedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        return { success: true };
    } catch (error) {
        console.error("Error updating post status:", error);
        return { success: false, error: "Failed to update status." };
    }
}

/**
 * Toggles the featured status of a post (admin only).
 * @param {string} postId - The ID of the post to toggle.
 * @param {boolean} isFeatured - Whether the post should be featured.
 * @returns {Promise<object>} A promise that resolves on success.
 */
async function toggleFeaturedStatus(postId, isFeatured) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "Authentication required." };
    }

    // Verify admin status server-side
    try {
        const isAdmin = await isUserAdmin();
        if (!isAdmin) {
            console.error("Unauthorized access attempt to toggle featured status");
            return { success: false, error: "Admin privileges required." };
        }

        const docRef = db.collection("posts").doc(postId);
        await docRef.update({ 
            isFeatured: isFeatured,
            featuredBy: user.uid,
            featuredAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        return { success: true };
    } catch (error) {
        console.error("Error toggling featured status:", error);
        return { success: false, error: "Failed to toggle featured status." };
    }
}

/**
 * Fetches all blog posts from Firestore (admin only).
 * @param {string} status - Optional filter by status ("pending", "approved", "rejected", or "all")
 * @returns {Promise<object>} A promise that resolves with all posts.
 */
async function getAllPosts(status = "all") {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "Authentication required." };
    }

    // Verify admin status server-side
    try {
        const isAdmin = await isUserAdmin();
        if (!isAdmin) {
            console.error("Unauthorized access attempt to fetch all posts");
            return { success: false, error: "Admin privileges required." };
        }

        let query = db.collection("posts").orderBy("createdAt", "desc");
        
        // Apply status filter if specified
        if (status && status !== "all") {
            query = query.where("status", "==", status);
        }

        const snapshot = await query.get();

        if (snapshot.empty) {
            console.log("No posts found.");
            return { success: true, posts: [] };
        }

        const posts = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        return { success: true, posts: posts };

    } catch (error) {
        console.error("Error fetching all posts:", error);
        return { success: false, error: "Failed to fetch posts." };
    }
}

/**
 * Permanently deletes a post from Firestore (admin only).
 * @param {string} postId - The ID of the post to delete.
 * @returns {Promise<object>} A promise that resolves on success.
 */
async function deletePostPermanently(postId) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "Authentication required." };
    }

    // Verify admin status server-side
    try {
        const isAdmin = await isUserAdmin();
        if (!isAdmin) {
            console.error("Unauthorized access attempt to delete post");
            return { success: false, error: "Admin privileges required." };
        }

        // Delete the post document
        await db.collection("posts").doc(postId).delete();
        
        console.log("Post deleted permanently:", postId);
        return { success: true };

    } catch (error) {
        console.error("Error deleting post:", error);
        return { success: false, error: "Failed to delete post." };
    }
}

// users.js
/**
 * users.js
 * This file contains functions for interacting with the 'users' collection
 * in Firestore and managing user profile data, including photo uploads.
 */

/**
 * Fetches a user's profile document from Firestore.
 * @param {string} userId - The UID of the user to fetch.
 * @returns {Promise<object>} A promise that resolves with the user's profile data.
 */
async function getUserProfile(userId) {
    try {
        const docRef = db.collection("users").doc(userId);
        const docSnap = await docRef.get();
        if (docSnap.exists) {
            return { success: true, profile: docSnap.data() };
        } else {
            return { success: false, error: "User profile not found." };
        }
    } catch (error) {
        console.error("Error getting user profile:", error);
        return { success: false, error: "Failed to fetch user profile." };
    }
}

/**
 * Updates a user's profile data in Firestore.
 * @param {string} userId - The UID of the user to update.
 * @param {object} profileData - An object with the fields to update (e.g., { displayName, bio }).
 * @returns {Promise<object>} A promise that resolves on success.
 */
async function updateUserProfile(userId, profileData) {
    try {
        const docRef = db.collection("users").doc(userId);
        await docRef.update(profileData);
        return { success: true };
    } catch (error) {
        console.error("Error updating profile:", error);
        return { success: false, error: "Failed to update profile." };
    }
}

/**
 * Uploads a profile picture to Firebase Storage and returns the download URL.
 * @param {string} userId - The UID of the user.
 * @param {File} file - The image file to upload.
 * @returns {Promise<object>} A promise that resolves with the public URL of the uploaded image.
 */
async function uploadProfilePicture(userId, file) {
    try {
        // Create a storage reference
        const storageRef = firebase.storage().ref();
        // Create a reference to 'profile_pictures/{userId}/{fileName}'
        const fileRef = storageRef.child(`profile_pictures/${userId}/${file.name}`);

        // Upload the file
        const snapshot = await fileRef.put(file);

        // Get the download URL
        const downloadURL = await snapshot.ref.getDownloadURL();

        return { success: true, url: downloadURL };
    } catch (error) {
        console.error("Error uploading photo:", error);
        return { success: false, error: "Failed to upload photo." };
    }
}


/**
 * Checks if the current user is an admin.
 * This is an alias for the isUserAdmin function from auth.js
 * @returns {Promise<boolean>}
 */
async function checkUserAdminStatus() {
    console.log("checkUserAdminStatus called");
    const result = await isUserAdmin();
    console.log("checkUserAdminStatus result:", result);
    return result;
}

// Make checkUserAdminStatus globally accessible
window.checkUserAdminStatus = checkUserAdminStatus;

/**
 * Simple admin check for testing
 * @returns {Promise<boolean>}
 */
async function testAdminStatus() {
    const user = auth.currentUser;
    if (!user) {
        console.log("No user logged in");
        return false;
    }
    
    try {
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (userDoc.exists) {
            const userData = userDoc.data();
            console.log("Test admin check - User data:", userData);
            return userData.isAdmin === true;
        }
        return false;
    } catch (error) {
        console.error("Test admin check error:", error);
        return false;
    }
}

// comments.js
/**
 * comments.js
 * This file contains functions for handling comments and reactions on blog posts.
 */

/*
    FIRESTORE DATABASE STRUCTURE:
    
    'comments' collection:
    - postId (string): ID of the blog post
    - authorId (string): User ID of the commenter
    - authorName (string): Display name of the commenter
    - text (string): Comment content
    - createdAt (timestamp): When the comment was posted
    - status (string): "approved" or "pending" (for moderation if needed)
    - parentId (string, optional): ID of parent comment for replies
    - replyCount (number): Number of replies to this comment
    
    'reactions' collection:
    - postId (string): ID of the blog post
    - userId (string): User ID who reacted
    - type (string): "like", "heart", "celebrate", "insightful"
    - createdAt (timestamp): When the reaction was made
    
    'bookmarks' collection:
    - userId (string): User ID who bookmarked
    - postId (string): ID of the bookmarked post
    - createdAt (timestamp): When the bookmark was made
    
    'userProfiles' collection:
    - userId (string): User ID (document ID)
    - bio (string): User biography
    - profilePicture (string): URL to profile picture
    - joinedAt (timestamp): When user joined
    - stats (object): { postsCount, commentsCount, reactionsReceived }
    - socialLinks (object): { website, twitter, linkedin, github }
*/

// Current post ID (will be set when page loads)
let currentPostId = null;

/**
 * Adds a comment or reply to a blog post
 */
async function addComment(postId, commentText, parentId = null) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "You must be logged in to comment." };
    }

    if (!commentText.trim()) {
        return { success: false, error: "Comment cannot be empty." };
    }

    try {
        const newComment = {
            postId: postId,
            authorId: user.uid,
            authorName: user.displayName || user.email,
            text: commentText.trim(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            status: "approved", // Auto-approve for now, can add moderation later
            replyCount: 0
        };

        // Add parentId if this is a reply
        if (parentId) {
            newComment.parentId = parentId;
        }

        const docRef = await db.collection("comments").add(newComment);

        // If this is a reply, update the parent comment's reply count
        if (parentId) {
            await db.collection("comments").doc(parentId).update({
                replyCount: firebase.firestore.FieldValue.increment(1)
            });
        }

        // Update user's comment count in their profile stats
        try {
            const currentStats = await calculateUserStats(user.uid);
            if (currentStats.success) {
                await updateUserStats(user.uid, currentStats.stats);
            }
        } catch (error) {
            console.log("Note: Stats update failed, but comment was posted successfully");
        }

        return { success: true, message: parentId ? "Reply posted successfully!" : "Comment posted successfully!" };

    } catch (error) {
        console.error("Error adding comment:", error);
        return { success: false, error: "Failed to post comment." };
    }
}

/**
 * Gets all approved comments for a specific post, organized by threading
 */
async function getCommentsForPost(postId) {
    try {
        const snapshot = await db.collection("comments")
            .where("postId", "==", postId)
            .where("status", "==", "approved")
            .orderBy("createdAt", "desc")
            .limit(50) // Limit to prevent performance issues
            .get();

        const allComments = [];
        snapshot.forEach(doc => {
            allComments.push({
                id: doc.id,
                ...doc.data()
            });
        });

        // Organize into parent comments and replies
        const parentComments = allComments.filter(comment => !comment.parentId);
        const replies = allComments.filter(comment => comment.parentId);

        // Group replies by parent ID
        const repliesByParent = {};
        replies.forEach(reply => {
            if (!repliesByParent[reply.parentId]) {
                repliesByParent[reply.parentId] = [];
            }
            repliesByParent[reply.parentId].push(reply);
        });

        // Sort replies within each parent (oldest first for replies)
        Object.keys(repliesByParent).forEach(parentId => {
            repliesByParent[parentId].sort((a, b) => {
                const aTime = a.createdAt ? a.createdAt.seconds : 0;
                const bTime = b.createdAt ? b.createdAt.seconds : 0;
                return aTime - bTime; // Oldest first for replies
            });
        });

        return { success: true, comments: parentComments, replies: repliesByParent };

    } catch (error) {
        console.error("Error fetching comments:", error);
        return { success: false, error: "Failed to load comments." };
    }
}

/**
 * Deletes a comment (only by author or admin)
 */
async function deleteComment(commentId) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "You must be logged in." };
    }

    try {
        // Get the comment to check ownership
        const commentDoc = await db.collection("comments").doc(commentId).get();
        if (!commentDoc.exists) {
            return { success: false, error: "Comment not found." };
        }

        const commentData = commentDoc.data();
        const isAuthor = commentData.authorId === user.uid;
        const isAdmin = typeof isUserAdmin === 'function' ? await isUserAdmin() : false;

        if (!isAuthor && !isAdmin) {
            return { success: false, error: "You can only delete your own comments." };
        }

        await db.collection("comments").doc(commentId).delete();
        return { success: true, message: "Comment deleted successfully!" };

    } catch (error) {
        console.error("Error deleting comment:", error);
        return { success: false, error: "Failed to delete comment." };
    }
}

/**
 * Toggles a reaction on a blog post
 */
async function toggleReaction(postId, reactionType) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "You must be logged in to react." };
    }

    try {
        // Check if user already has this reaction
        const existingReaction = await db.collection("reactions")
            .where("postId", "==", postId)
            .where("userId", "==", user.uid)
            .where("type", "==", reactionType)
            .get();

        if (!existingReaction.empty) {
            // Remove existing reaction
            const reactionDoc = existingReaction.docs[0];
            await db.collection("reactions").doc(reactionDoc.id).delete();
            
            return { success: true, action: "removed", message: "Reaction removed!" };
        } else {
            // Add new reaction
            const newReaction = {
                postId: postId,
                userId: user.uid,
                type: reactionType,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            await db.collection("reactions").add(newReaction);
            
            return { success: true, action: "added", message: "Reaction added!" };
        }

    } catch (error) {
        console.error("Error toggling reaction:", error);
        return { success: false, error: "Failed to update reaction." };
    }
}

/**
 * Gets reaction counts for a specific post
 */
async function getReactionsForPost(postId) {
    try {
        const snapshot = await db.collection("reactions")
            .where("postId", "==", postId)
            .get();

        const reactions = {
            like: 0,
            heart: 0,
            celebrate: 0,
            insightful: 0
        };

        const userReactions = new Set();
        const user = auth.currentUser;

        snapshot.forEach(doc => {
            const data = doc.data();
            reactions[data.type]++;
            
            // Track current user's reactions
            if (user && data.userId === user.uid) {
                userReactions.add(data.type);
            }
        });

        return { success: true, reactions: reactions, userReactions: userReactions };

    } catch (error) {
        console.error("Error fetching reactions:", error);
        return { success: false, error: "Failed to load reactions." };
    }
}

/**
 * Toggles bookmark status for a post
 */
async function toggleBookmark(postId) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "You must be logged in to bookmark posts." };
    }

    try {
        // Check if post is already bookmarked
        const existingBookmark = await db.collection("bookmarks")
            .where("userId", "==", user.uid)
            .where("postId", "==", postId)
            .get();

        if (!existingBookmark.empty) {
            // Remove bookmark
            const bookmarkDoc = existingBookmark.docs[0];
            await db.collection("bookmarks").doc(bookmarkDoc.id).delete();
            return { success: true, action: "removed", message: "Bookmark removed!" };
        } else {
            // Add bookmark
            const newBookmark = {
                userId: user.uid,
                postId: postId,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            await db.collection("bookmarks").add(newBookmark);
            return { success: true, action: "added", message: "Post bookmarked!" };
        }

    } catch (error) {
        console.error("Error toggling bookmark:", error);
        return { success: false, error: "Failed to update bookmark." };
    }
}

/**
 * Checks if a post is bookmarked by the current user
 */
async function isPostBookmarked(postId) {
    const user = auth.currentUser;
    if (!user) return false;

    try {
        const snapshot = await db.collection("bookmarks")
            .where("userId", "==", user.uid)
            .where("postId", "==", postId)
            .get();

        return !snapshot.empty;
    } catch (error) {
        console.error("Error checking bookmark status:", error);
        return false;
    }
}

/**
 * Gets all bookmarked posts for a user
 */
async function getUserBookmarks(userId) {
    try {
        const snapshot = await db.collection("bookmarks")
            .where("userId", "==", userId)
            .orderBy("createdAt", "desc")
            .get();

        const bookmarkIds = [];
        snapshot.forEach(doc => {
            bookmarkIds.push(doc.data().postId);
        });

        return { success: true, bookmarkIds: bookmarkIds };
    } catch (error) {
        console.error("Error fetching bookmarks:", error);
        return { success: false, error: "Failed to load bookmarks." };
    }
}

/**
 * User profile functions
 */

/**
 * Creates or updates user profile
 */
async function updateUserProfile(profileData) {
    const user = auth.currentUser;
    if (!user) {
        return { success: false, error: "You must be logged in." };
    }

    try {
        const profileRef = db.collection("userProfiles").doc(user.uid);
        const existingProfile = await profileRef.get();

        const profileUpdate = {
            bio: profileData.bio || "",
            socialLinks: profileData.socialLinks || {},
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        if (!existingProfile.exists) {
            // Create new profile
            profileUpdate.joinedAt = firebase.firestore.FieldValue.serverTimestamp();
            profileUpdate.stats = {
                postsCount: 0,
                commentsCount: 0,
                reactionsReceived: 0
            };
        }

        await profileRef.set(profileUpdate, { merge: true });
        return { success: true, message: "Profile updated successfully!" };

    } catch (error) {
        console.error("Error updating profile:", error);
        return { success: false, error: "Failed to update profile." };
    }
}

/**
 * Gets user profile data
 */
async function getUserProfile(userId) {
    try {
        const profileDoc = await db.collection("userProfiles").doc(userId).get();
        
        if (profileDoc.exists) {
            return { success: true, profile: { id: userId, ...profileDoc.data() } };
        } else {
            // Return default profile if none exists
            return { 
                success: true, 
                profile: {
                    id: userId,
                    bio: "",
                    socialLinks: {},
                    stats: { postsCount: 0, commentsCount: 0, reactionsReceived: 0 },
                    joinedAt: null
                }
            };
        }
    } catch (error) {
        console.error("Error fetching profile:", error);
        return { success: false, error: "Failed to load profile." };
    }
}

/**
 * Gets posts written by a specific user
 */
async function getUserPosts(userId) {
    try {
        const snapshot = await db.collection("posts")
            .where("authorId", "==", userId)
            .where("status", "==", "approved")
            .orderBy("createdAt", "desc")
            .get();

        const posts = [];
        snapshot.forEach(doc => {
            posts.push({
                id: doc.id,
                ...doc.data()
            });
        });

        return { success: true, posts: posts };
    } catch (error) {
        console.error("Error fetching user posts:", error);
        return { success: false, error: "Failed to load user posts." };
    }
}

/**
 * Calculates user statistics from their activity
 */
async function calculateUserStats(userId) {
    try {
        // Count approved posts
        const postsSnapshot = await db.collection("posts")
            .where("authorId", "==", userId)
            .where("status", "==", "approved")
            .get();
        const postsCount = postsSnapshot.size;

        // Count approved comments
        const commentsSnapshot = await db.collection("comments")
            .where("authorId", "==", userId)
            .where("status", "==", "approved")
            .get();
        const commentsCount = commentsSnapshot.size;

        // Count reactions received on user's posts
        let reactionsReceived = 0;
        const userPostIds = [];
        postsSnapshot.forEach(doc => {
            userPostIds.push(doc.id);
        });

        if (userPostIds.length > 0) {
            const reactionsSnapshot = await db.collection("reactions")
                .where("postId", "in", userPostIds)
                .get();
            reactionsReceived = reactionsSnapshot.size;
        }

        return {
            success: true,
            stats: {
                postsCount,
                commentsCount,
                reactionsReceived
            }
        };
    } catch (error) {
        console.error("Error calculating user stats:", error);
        return {
            success: false,
            error: "Failed to calculate stats.",
            stats: { postsCount: 0, commentsCount: 0, reactionsReceived: 0 }
        };
    }
}

/**
 * Updates user profile statistics
 */
async function updateUserStats(userId, stats) {
    try {
        const profileRef = db.collection("userProfiles").doc(userId);
        await profileRef.set({
            stats: stats,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        return { success: true, message: "Stats updated successfully!" };
    } catch (error) {
        console.error("Error updating user stats:", error);
        return { success: false, error: "Failed to update stats." };
    }
}

/**
 * Refreshes user statistics by recalculating them
 */
async function refreshUserStats(userId) {
    const statsResult = await calculateUserStats(userId);
    if (statsResult.success) {
        await updateUserStats(userId, statsResult.stats);
        return statsResult.stats;
    }
    return { postsCount: 0, commentsCount: 0, reactionsReceived: 0 };
}

/**
 * Displays comments for the current post with threading
 */
async function displayComments(postId) {
    const commentsLoading = document.getElementById('comments-loading');
    const commentsList = document.getElementById('comments-list');
    const noComments = document.getElementById('no-comments');

    // Check if elements exist before proceeding
    if (!commentsLoading || !commentsList || !noComments) {
        return; // Silently return if elements don't exist
    }

    // Show loading
    commentsLoading.classList.remove('hidden');
    commentsList.classList.add('hidden');
    noComments.classList.add('hidden');

    try {
        const result = await getCommentsForPost(postId);

        // Hide loading
        commentsLoading.classList.add('hidden');

        if (result.success) {
            const totalComments = result.comments.length + Object.values(result.replies).reduce((sum, replies) => sum + replies.length, 0);
            
            if (totalComments > 0) {
                commentsList.innerHTML = '';
                
                // Display parent comments with their replies
                result.comments.forEach(comment => {
                    const commentElement = createCommentElement(comment, result.replies[comment.id] || []);
                    commentsList.appendChild(commentElement);
                });
                
                commentsList.classList.remove('hidden');
            } else {
                noComments.classList.remove('hidden');
            }
        } else {
            commentsList.innerHTML = '<p class="text-red-500">Failed to load comments.</p>';
            commentsList.classList.remove('hidden');
        }
    } catch (error) {
        console.warn('Error loading comments:', error);
        commentsLoading.classList.add('hidden');
        if (commentsList) {
            commentsList.innerHTML = '<p class="text-red-500">Failed to load comments.</p>';
            commentsList.classList.remove('hidden');
        }
    }
}

/**
 * Creates a comment DOM element with replies
 */
function createCommentElement(comment, replies = []) {
    const commentDiv = document.createElement('div');
    commentDiv.className = 'comment-item bg-gray-50 rounded-lg p-4 pl-6 mb-4';
    
    const commentDate = comment.createdAt ? 
        new Date(comment.createdAt.seconds * 1000).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }) : 'Just now';

    const user = auth.currentUser;
    const isAdmin = typeof isUserAdmin === 'function' ? isUserAdmin() : false;
    const canDelete = user && (comment.authorId === user.uid || isAdmin);
    const canReply = user !== null;

    commentDiv.innerHTML = `
        <div class="flex items-start justify-between">
            <div class="flex-1">
                <div class="flex items-center space-x-2 mb-2">
                    <a href="profile.html?user=${comment.authorId}" class="font-semibold text-gray-800 hover:text-blue-600 transition duration-200">${comment.authorName}</a>
                    <span class="text-sm text-gray-500">${commentDate}</span>
                </div>
                <p class="text-gray-700 leading-relaxed mb-3">${comment.text}</p>
                
                <!-- Action buttons -->
                <div class="flex items-center space-x-4 text-sm">
                    ${canReply ? `
                        <button onclick="toggleReplyForm('${comment.id}')" class="text-blue-600 hover:text-blue-800 flex items-center space-x-1">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                            </svg>
                            <span>Reply</span>
                        </button>
                    ` : ''}
                    ${replies.length > 0 ? `
                        <span class="text-gray-500">${replies.length} ${replies.length === 1 ? 'reply' : 'replies'}</span>
                    ` : ''}
                </div>
                
                <!-- Reply form (hidden by default) -->
                ${canReply ? `
                    <div id="reply-form-${comment.id}" class="hidden mt-4 bg-white rounded-lg p-3 border-l-4 border-blue-500">
                        <form onsubmit="handleReplySubmit(event, '${comment.id}')" class="space-y-3">
                            <textarea 
                                placeholder="Write a reply..." 
                                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none" 
                                rows="2"
                                required
                            ></textarea>
                            <div class="flex justify-end space-x-2">
                                <button type="button" onclick="toggleReplyForm('${comment.id}')" class="px-3 py-1 text-gray-600 hover:text-gray-800">
                                    Cancel
                                </button>
                                <button type="submit" class="px-4 py-1 bg-blue-600 text-white rounded hover:bg-blue-700">
                                    Reply
                                </button>
                            </div>
                        </form>
                    </div>
                ` : ''}
            </div>
            ${canDelete ? `
                <button onclick="handleDeleteComment('${comment.id}')" class="text-red-500 hover:text-red-700 text-sm ml-4">
                    Delete
                </button>
            ` : ''}
        </div>
        
        <!-- Replies section -->
        ${replies.length > 0 ? `
            <div class="ml-6 mt-4 space-y-3 border-l-2 border-gray-200 pl-4">
                ${replies.map(reply => createReplyElement(reply)).join('')}
            </div>
        ` : ''}
    `;

    return commentDiv;
}

/**
 * Creates a reply DOM element
 */
function createReplyElement(reply) {
    const replyDate = reply.createdAt ? 
        new Date(reply.createdAt.seconds * 1000).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }) : 'Just now';

    const user = auth.currentUser;
    const isAdmin = typeof isUserAdmin === 'function' ? isUserAdmin() : false;
    const canDelete = user && (reply.authorId === user.uid || isAdmin);

    return `
        <div class="bg-white rounded-lg p-3 border border-gray-200">
            <div class="flex items-start justify-between">
                <div class="flex-1">
                    <div class="flex items-center space-x-2 mb-2">
                        <a href="profile.html?user=${reply.authorId}" class="font-semibold text-gray-800 text-sm hover:text-blue-600 transition duration-200">${reply.authorName}</a>
                        <span class="text-xs text-gray-500">${replyDate}</span>
                    </div>
                    <p class="text-gray-700 text-sm leading-relaxed">${reply.text}</p>
                </div>
                ${canDelete ? `
                    <button onclick="handleDeleteComment('${reply.id}')" class="text-red-500 hover:text-red-700 text-xs ml-2">
                        Delete
                    </button>
                ` : ''}
            </div>
        </div>
    `;
}

/**
 * Displays reactions for the current post
 */
async function displayReactions(postId) {
    try {
        const result = await getReactionsForPost(postId);

        if (result.success) {
            // Update counts with error handling
            const likeCount = document.getElementById('like-count');
            const heartCount = document.getElementById('heart-count');
            const celebrateCount = document.getElementById('celebrate-count');
            const insightfulCount = document.getElementById('insightful-count');

            if (likeCount) likeCount.textContent = result.reactions.like;
            if (heartCount) heartCount.textContent = result.reactions.heart;
            if (celebrateCount) celebrateCount.textContent = result.reactions.celebrate;
            if (insightfulCount) insightfulCount.textContent = result.reactions.insightful;

            // Update active states
            const user = auth.currentUser;
            if (user) {
                const likeBtn = document.getElementById('like-btn');
                const heartBtn = document.getElementById('heart-btn');
                const celebrateBtn = document.getElementById('celebrate-btn');
                const insightfulBtn = document.getElementById('insightful-btn');

                if (likeBtn) likeBtn.classList.toggle('active', result.userReactions.has('like'));
                if (heartBtn) heartBtn.classList.toggle('active', result.userReactions.has('heart'));
                if (celebrateBtn) celebrateBtn.classList.toggle('active', result.userReactions.has('celebrate'));
                if (insightfulBtn) insightfulBtn.classList.toggle('active', result.userReactions.has('insightful'));
            }
        }
    } catch (error) {
        console.warn('Error loading reactions:', error);
    }
}

/**
 * Handles comment form submission
 */
async function handleCommentSubmit(event) {
    event.preventDefault();
    
    const commentText = document.getElementById('comment-text').value;
    const submitBtn = event.target.querySelector('button[type="submit"]');
    
    // Disable submit button
    submitBtn.disabled = true;
    submitBtn.textContent = 'Posting...';

    const result = await addComment(currentPostId, commentText);

    if (result.success) {
        // Clear form
        document.getElementById('comment-text').value = '';
        
        // Refresh comments
        await displayComments(currentPostId);
    } else {
        alert(result.error);
    }

    // Re-enable submit button
    submitBtn.disabled = false;
    submitBtn.textContent = 'Post Comment';
}

/**
 * Handles reply form submission
 */
async function handleReplySubmit(event, parentId) {
    event.preventDefault();
    
    const textarea = event.target.querySelector('textarea');
    const replyText = textarea.value;
    const submitBtn = event.target.querySelector('button[type="submit"]');
    
    // Disable submit button
    submitBtn.disabled = true;
    submitBtn.textContent = 'Replying...';

    const result = await addComment(currentPostId, replyText, parentId);

    if (result.success) {
        // Hide reply form
        toggleReplyForm(parentId);
        
        // Refresh comments
        await displayComments(currentPostId);
    } else {
        alert(result.error);
    }

    // Re-enable submit button
    submitBtn.disabled = false;
    submitBtn.textContent = 'Reply';
}

/**
 * Toggles reply form visibility
 */
function toggleReplyForm(commentId) {
    const replyForm = document.getElementById(`reply-form-${commentId}`);
    if (replyForm) {
        const isHidden = replyForm.classList.contains('hidden');
        
        // Hide all other reply forms first
        document.querySelectorAll('[id^="reply-form-"]').forEach(form => {
            form.classList.add('hidden');
        });
        
        if (isHidden) {
            replyForm.classList.remove('hidden');
            // Focus on the textarea
            const textarea = replyForm.querySelector('textarea');
            if (textarea) {
                textarea.focus();
            }
        }
    }
}

/**
 * Handles reaction button clicks
 */
async function handleReactionClick(reactionType) {
    const user = auth.currentUser;
    if (!user) {
        alert('Please log in to react to this post.');
        return;
    }

    // Get the button element for immediate visual feedback
    const button = document.getElementById(`${reactionType}-btn`);
    const countElement = document.getElementById(`${reactionType}-count`);
    
    if (!button || !countElement) {
        console.error('Reaction button or count element not found');
        return;
    }

    // Immediate visual feedback
    const isCurrentlyActive = button.classList.contains('active');
    const currentCount = parseInt(countElement.textContent) || 0;
    
    // Optimistically update UI
    if (isCurrentlyActive) {
        button.classList.remove('active');
        countElement.textContent = Math.max(0, currentCount - 1);
    } else {
        button.classList.add('active');
        countElement.textContent = currentCount + 1;
    }

    const result = await toggleReaction(currentPostId, reactionType);
    
    if (result.success) {
        // Only refresh if there was an error or if we need to sync with server
        // For now, we'll trust our optimistic update
        console.log(`Reaction ${result.action}: ${reactionType}`);
    } else {
        // Revert optimistic update on error
        if (isCurrentlyActive) {
            button.classList.add('active');
            countElement.textContent = currentCount;
        } else {
            button.classList.remove('active');
            countElement.textContent = Math.max(0, currentCount - 1);
        }
        alert(result.error);
    }
}

/**
 * Handles comment deletion
 */
async function handleDeleteComment(commentId) {
    if (!confirm('Are you sure you want to delete this comment?')) {
        return;
    }

    const result = await deleteComment(commentId);
    
    if (result.success) {
        // Refresh comments
        await displayComments(currentPostId);
    } else {
        alert(result.error);
    }
}

/**
 * Handles bookmark button click
 */
async function handleBookmarkClick() {
    const user = auth.currentUser;
    if (!user) {
        alert('Please log in to bookmark posts.');
        return;
    }

    const bookmarkBtn = document.getElementById('bookmark-btn');
    const result = await toggleBookmark(currentPostId);
    
    if (result.success) {
        updateBookmarkButton(result.action === 'added');
    } else {
        alert(result.error);
    }
}

/**
 * Updates bookmark button appearance
 */
function updateBookmarkButton(isBookmarked) {
    const bookmarkBtn = document.getElementById('bookmark-btn');
    const bookmarkIcon = bookmarkBtn.querySelector('svg');
    const bookmarkText = bookmarkBtn.querySelector('span');
    
    if (isBookmarked) {
        bookmarkBtn.classList.add('bookmarked');
        bookmarkText.textContent = 'Bookmarked';
        bookmarkIcon.setAttribute('fill', 'currentColor');
    } else {
        bookmarkBtn.classList.remove('bookmarked');
        bookmarkText.textContent = 'Bookmark';
        bookmarkIcon.setAttribute('fill', 'none');
    }
}

/**
 * Initializes comments, reactions, and bookmarks for the current post
 */
function initializeCommentsAndReactions(postId) {
    currentPostId = postId;
    
    // Set up comment form
    const commentForm = document.getElementById('comment-form');
    const commentFormContainer = document.getElementById('comment-form-container');
    const commentLoginPrompt = document.getElementById('comment-login-prompt');
    
    if (commentForm) {
        commentForm.addEventListener('submit', handleCommentSubmit);
    }

    // Show appropriate UI based on auth state
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            if (commentFormContainer) commentFormContainer.classList.remove('hidden');
            if (commentLoginPrompt) commentLoginPrompt.classList.add('hidden');
            
            // Check bookmark status (non-blocking)
            isPostBookmarked(postId).then(isBookmarked => {
                updateBookmarkButton(isBookmarked);
            }).catch(error => {
                console.warn('Failed to check bookmark status:', error);
            });
        } else {
            if (commentFormContainer) commentFormContainer.classList.add('hidden');
            if (commentLoginPrompt) commentLoginPrompt.classList.remove('hidden');
            
            // Reset bookmark button for logged out users
            updateBookmarkButton(false);
        }
    });

    // Set up reaction buttons with proper checks
    const likeBtn = document.getElementById('like-btn');
    const heartBtn = document.getElementById('heart-btn');
    const celebrateBtn = document.getElementById('celebrate-btn');
    const insightfulBtn = document.getElementById('insightful-btn');

    if (likeBtn) {
        likeBtn.addEventListener('click', () => handleReactionClick('like'));
    }

    if (heartBtn) {
        heartBtn.addEventListener('click', () => handleReactionClick('heart'));
    }

    if (celebrateBtn) {
        celebrateBtn.addEventListener('click', () => handleReactionClick('celebrate'));
    }

    if (insightfulBtn) {
        insightfulBtn.addEventListener('click', () => handleReactionClick('insightful'));
    }

    // Set up bookmark button
    const bookmarkBtn = document.getElementById('bookmark-btn');
    if (bookmarkBtn) {
        bookmarkBtn.addEventListener('click', handleBookmarkClick);
    }

    // Load reactions first (faster, less data)
    setTimeout(() => {
        displayReactions(postId).catch(error => {
            console.warn('Failed to load reactions:', error);
        });
    }, 500); // 0.5 second delay

    // Load comments much later (more data, can wait)
    setTimeout(() => {
        displayComments(postId).catch(error => {
            console.warn('Failed to load comments:', error);
        });
    }, 1500); // 1.5 second delay after reactions
}

// Make functions globally available
window.initializeCommentsAndReactions = initializeCommentsAndReactions;
window.handleCommentSubmit = handleCommentSubmit;
window.handleReplySubmit = handleReplySubmit;
window.handleReactionClick = handleReactionClick;
window.handleDeleteComment = handleDeleteComment;
window.handleBookmarkClick = handleBookmarkClick;
window.toggleReplyForm = toggleReplyForm;
window.displayComments = displayComments;
window.displayReactions = displayReactions;

// security.js
/**
 * security.js
 * Enhanced security measures for the GIKI Chronicles admin system
 */

// Rate limiting for admin actions
const adminActionLimiter = {
    attempts: new Map(),
    maxAttempts: 5,
    windowMs: 15 * 60 * 1000, // 15 minutes
    
    checkLimit(userId, action) {
        const key = `${userId}-${action}`;
        const now = Date.now();
        const userAttempts = this.attempts.get(key) || [];
        
        // Remove old attempts outside the window
        const recentAttempts = userAttempts.filter(time => now - time < this.windowMs);
        
        if (recentAttempts.length >= this.maxAttempts) {
            return false;
        }
        
        recentAttempts.push(now);
        this.attempts.set(key, recentAttempts);
        return true;
    },
    
    reset(userId, action) {
        const key = `${userId}-${action}`;
        this.attempts.delete(key);
    }
};

// Enhanced admin validation with additional security checks
async function validateAdminAccess(action = 'general') {
    const user = auth.currentUser;
    if (!user) {
        console.error("Admin validation failed: No authenticated user");
        return { valid: false, error: "Authentication required" };
    }

    // Rate limiting check
    if (!adminActionLimiter.checkLimit(user.uid, action)) {
        console.error(`Rate limit exceeded for user ${user.uid} on action ${action}`);
        return { valid: false, error: "Too many admin actions. Please wait before trying again." };
    }

    try {
        // Verify admin status
        const isAdmin = await isUserAdmin();
        if (!isAdmin) {
            console.error(`Unauthorized admin access attempt by user ${user.uid} for action: ${action}`);
            return { valid: false, error: "Admin privileges required" };
        }

        // Additional security: Check if user account is still active
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (!userDoc.exists) {
            console.error(`Admin validation failed: User document not found for ${user.uid}`);
            return { valid: false, error: "User account not found" };
        }

        const userData = userDoc.data();
        if (userData.isSuspended) {
            console.error(`Admin validation failed: Suspended user ${user.uid} attempted admin action`);
            return { valid: false, error: "Account suspended" };
        }

        // Log admin action for audit trail
        await logAdminAction(user.uid, action, 'success');
        
        return { valid: true, user: user, userData: userData };
    } catch (error) {
        console.error("Admin validation error:", error);
        return { valid: false, error: "Validation failed" };
    }
}

// Audit trail for admin actions
async function logAdminAction(userId, action, status, details = {}) {
    try {
        await db.collection('admin_audit_log').add({
            userId: userId,
            action: action,
            status: status,
            details: details,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            userAgent: navigator.userAgent,
            ipAddress: 'client-side' // In production, this should come from server
        });
    } catch (error) {
        console.error("Failed to log admin action:", error);
    }
}

// Enhanced session validation
function validateSession() {
    const user = auth.currentUser;
    if (!user) return false;
    
    // Check if token is recent (within last hour)
    const tokenTime = user.metadata.lastSignInTime;
    if (tokenTime) {
        const lastSignIn = new Date(tokenTime);
        const now = new Date();
        const hoursSinceSignIn = (now - lastSignIn) / (1000 * 60 * 60);
        
        if (hoursSinceSignIn > 24) { // Require re-authentication after 24 hours
            console.warn("Session expired, requiring re-authentication");
            return false;
        }
    }
    
    return true;
}

// Input sanitization for admin actions
function sanitizeAdminInput(input) {
    if (typeof input !== 'string') return input;
    
    // Remove potentially dangerous characters and scripts
    return input
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+\s*=/gi, '')
        .trim();
}

// Enhanced error handling for admin functions
function handleAdminError(error, context) {
    console.error(`Admin error in ${context}:`, error);
    
    // Log security-relevant errors
    if (error.code === 'permission-denied' || error.message.includes('permission')) {
        logAdminAction('unknown', context, 'permission_denied', { error: error.message });
    }
    
    return {
        success: false,
        error: "An error occurred. Please try again or contact support.",
        context: context
    };
}

// Export functions for use in other files
window.security = {
    validateAdminAccess,
    logAdminAction,
    validateSession,
    sanitizeAdminInput,
    handleAdminError,
    adminActionLimiter
}; 

// submissions.js
/**
 * submissions.js
 * This file contains functions for handling form submissions,
 * like the contact form, and saving them to Firestore.
 */

/*
    FIRESTORE DATABASE STRUCTURE for the 'submissions' collection:

    Each document in this collection will represent a single contact form entry.
    - name (string): The full name of the person submitting the form.
    - email (string): The email address of the person.
    - subject (string): The subject selected from the dropdown.
    - message (string): The content of the message.
    - submittedAt (timestamp): The date and time the form was submitted.
    - submittedBy (string, optional): The UID of the user if they were logged in.
*/

/**
 * Saves a contact form submission to the Firestore database.
 * @param {object} submissionData - An object containing the name, email, subject, and message.
 * @returns {Promise<object>} A promise that resolves on success or returns an error object on failure.
 */
async function saveContactSubmission(submissionData) {
    try {
        const user = auth.currentUser; // Check if a user is logged in

        const newSubmission = {
            name: submissionData.name,
            email: submissionData.email,
            subject: submissionData.subject,
            message: submissionData.message,
            submittedAt: firebase.firestore.FieldValue.serverTimestamp(),
            // Add the user's ID if they are logged in for context
            submittedBy: user ? user.uid : "Guest"
        };

        await db.collection("submissions").add(newSubmission);
        console.log("Contact form submission saved successfully.");
        return { success: true };

    } catch (error) {
        console.error("Error saving submission:", error);
        return { success: false, error: "Failed to send message." };
    }
}


// database-optimization.js
/**
 * Database Optimization Functions
 * Advanced Firestore query optimizations for better performance
 */

// Cache for frequently accessed data
const queryCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Optimized query with caching
async function getOptimizedGalleryPhotos(status = "approved", page = 0, limit = 12) {
    const cacheKey = `gallery_${status}_${page}_${limit}`;
    const cached = queryCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        console.log('Serving from cache:', cacheKey);
        return cached.data;
    }
    
    try {
        // Use composite indexes for better performance
        let query = db.collection("galleryPhotos")
            .where("status", "==", status)
            .orderBy("createdAt", "desc")
            .orderBy("isHighlighted", "desc"); // Secondary sort for better UX
        
        // Apply pagination with cursor
        if (page > 0) {
            const prevPageQuery = db.collection("galleryPhotos")
                .where("status", "==", status)
                .orderBy("createdAt", "desc")
                .orderBy("isHighlighted", "desc")
                .limit(page * limit);
            
            const prevPageSnapshot = await prevPageQuery.get();
            const lastDoc = prevPageSnapshot.docs[prevPageSnapshot.docs.length - 1];
            
            if (lastDoc) {
                query = query.startAfter(lastDoc);
            }
        }
        
        const snapshot = await query.limit(limit).get();
        const photos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        const result = { success: true, photos };
        
        // Cache the result
        queryCache.set(cacheKey, {
            data: result,
            timestamp: Date.now()
        });
        
        return result;
    } catch (error) {
        console.error("Error fetching optimized gallery photos:", error);
        return { success: false, error: "Could not load photos." };
    }
}

// Batch operations for better performance
async function batchUpdatePhotoStatus(updates) {
    const batch = db.batch();
    
    updates.forEach(({ photoId, newStatus, options }) => {
        const photoRef = db.collection("galleryPhotos").doc(photoId);
        const updateData = {
            status: newStatus,
            reviewedAt: firebase.firestore.FieldValue.serverTimestamp(),
            reviewedBy: auth.currentUser.uid
        };
        
        if (typeof options.isHighlighted === 'boolean') {
            updateData.isHighlighted = options.isHighlighted;
        }
        
        if (newStatus === "rejected" && options.rejectionReason) {
            updateData.rejectionReason = options.rejectionReason;
        }
        
        batch.update(photoRef, updateData);
    });
    
    try {
        await batch.commit();
        return { success: true };
    } catch (error) {
        console.error("Error in batch update:", error);
        return { success: false, error: "Could not update photos." };
    }
}

// Optimized stats query with aggregation
async function getOptimizedGalleryStats() {
    const cacheKey = 'gallery_stats';
    const cached = queryCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
        return cached.data;
    }
    
    try {
        // Use Promise.all for parallel queries
        const [approved, pending, rejected] = await Promise.all([
            db.collection("galleryPhotos").where("status", "==", "approved").get(),
            db.collection("galleryPhotos").where("status", "==", "pending").get(),
            db.collection("galleryPhotos").where("status", "==", "rejected").get()
        ]);
        
        const stats = {
            approved: approved.size,
            pending: pending.size,
            rejected: rejected.size,
            total: approved.size + pending.size + rejected.size
        };
        
        const result = { success: true, stats };
        
        // Cache the result
        queryCache.set(cacheKey, {
            data: result,
            timestamp: Date.now()
        });
        
        return result;
    } catch (error) {
        console.error("Error fetching optimized gallery stats:", error);
        return { success: false, error: "Could not load statistics." };
    }
}

// Query with field selection for reduced data transfer
async function getPhotoMetadata(photoIds) {
    try {
        const photoRefs = photoIds.map(id => db.collection("galleryPhotos").doc(id));
        const snapshot = await db.getAll(...photoRefs);
        
        return snapshot.map(doc => ({
            id: doc.id,
            caption: doc.data().caption,
            category: doc.data().category,
            status: doc.data().status,
            createdAt: doc.data().createdAt,
            uploaderName: doc.data().uploaderName
        }));
    } catch (error) {
        console.error("Error fetching photo metadata:", error);
        return [];
    }
}

// Optimized search with indexing
async function searchPhotos(query, status = "approved", limit = 20) {
    try {
        // Use Firestore's built-in text search capabilities
        let firestoreQuery = db.collection("galleryPhotos")
            .where("status", "==", status);
        
        // Add search filters if query provided
        if (query) {
            // Search in caption and category
            firestoreQuery = firestoreQuery
                .where("searchableCaption", ">=", query.toLowerCase())
                .where("searchableCaption", "<=", query.toLowerCase() + '\uf8ff');
        }
        
        const snapshot = await firestoreQuery
            .orderBy("createdAt", "desc")
            .limit(limit)
            .get();
        
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
        console.error("Error searching photos:", error);
        return [];
    }
}

// Cache management
function clearCache() {
    queryCache.clear();
    console.log('Query cache cleared');
}

function getCacheStats() {
    return {
        size: queryCache.size,
        keys: Array.from(queryCache.keys())
    };
}

// Export functions
window.getOptimizedGalleryPhotos = getOptimizedGalleryPhotos;
window.batchUpdatePhotoStatus = batchUpdatePhotoStatus;
window.getOptimizedGalleryStats = getOptimizedGalleryStats;
window.getPhotoMetadata = getPhotoMetadata;
window.searchPhotos = searchPhotos;
window.clearCache = clearCache;
window.getCacheStats = getCacheStats;


// image-optimizer.js
/**
 * Advanced Image Optimization
 * Progressive loading, WebP support, and responsive images
 */

class ImageOptimizer {
    constructor() {
        this.supportedFormats = this.checkWebPSupport();
        this.breakpoints = {
            mobile: 480,
            tablet: 768,
            desktop: 1024,
            large: 1440
        };
    }
    
    // Check WebP support
    checkWebPSupport() {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    }
    
    // Generate responsive image URLs
    generateResponsiveUrls(originalUrl, alt = '') {
        if (!originalUrl.includes('cloudinary')) {
            return this.generateFallbackResponsiveUrls(originalUrl, alt);
        }
        
        const urls = {};
        
        // Generate different sizes for different devices
        Object.entries(this.breakpoints).forEach(([device, width]) => {
            const format = this.supportedFormats ? 'f_auto,q_auto' : 'q_auto';
            // Fix: Use c_scale to preserve aspect ratio instead of c_fill
            urls[device] = originalUrl.replace('/upload/', `/upload/c_scale,w_${width},${format}/`);
        });
        
        return urls;
    }
    
    // Generate fallback URLs for non-Cloudinary images
    generateFallbackResponsiveUrls(originalUrl, alt = '') {
        return {
            mobile: originalUrl,
            tablet: originalUrl,
            desktop: originalUrl,
            large: originalUrl
        };
    }
    
    // Create optimized image element
    createOptimizedImage(originalUrl, alt = '', className = '') {
        const responsiveUrls = this.generateResponsiveUrls(originalUrl, alt);
        
        const img = document.createElement('img');
        img.alt = alt;
        img.className = className;
        img.loading = 'lazy';
        
        // Set srcset for responsive images
        const srcset = Object.entries(responsiveUrls)
            .map(([device, url]) => `${url} ${this.breakpoints[device]}w`)
            .join(', ');
        
        img.srcset = srcset;
        img.sizes = '(max-width: 480px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw';
        
        // Set fallback src
        img.src = responsiveUrls.mobile;
        
        // Add error handling
        img.onerror = () => {
            img.src = originalUrl; // Fallback to original
        };
        
        return img;
    }
    
    // Progressive image loading with blur effect
    createProgressiveImage(originalUrl, alt = '', className = '') {
        const container = document.createElement('div');
        container.className = `progressive-image-container ${className}`;
        container.style.position = 'relative';
        container.style.overflow = 'hidden';
        
        // Create low-quality placeholder
        const placeholder = document.createElement('img');
        placeholder.src = this.generateLowQualityUrl(originalUrl);
        placeholder.className = 'progressive-placeholder';
        placeholder.style.filter = 'blur(10px)';
        placeholder.style.transition = 'opacity 0.3s ease-out';
        
        // Create high-quality image
        const highQuality = this.createOptimizedImage(originalUrl, alt);
        highQuality.className = 'progressive-high-quality';
        highQuality.style.position = 'absolute';
        highQuality.style.top = '0';
        highQuality.style.left = '0';
        highQuality.style.opacity = '0';
        highQuality.style.transition = 'opacity 0.3s ease-in';
        
        // Load high-quality image
        highQuality.onload = () => {
            highQuality.style.opacity = '1';
            placeholder.style.opacity = '0';
        };
        
        container.appendChild(placeholder);
        container.appendChild(highQuality);
        
        return container;
    }
    
    // Generate low-quality placeholder URL
    generateLowQualityUrl(originalUrl) {
        if (originalUrl.includes('cloudinary')) {
            return originalUrl.replace('/upload/', '/upload/c_scale,w_20,q_10,f_auto/');
        }
        return originalUrl;
    }
    
    // Optimize existing images on page
    optimizePageImages() {
        const images = document.querySelectorAll('img:not([data-optimized])');
        
        images.forEach(img => {
            if (img.src && !img.dataset.optimized) {
                // Skip gallery images that are already optimized by gallery-admin.js
                if (img.closest('#gallery-grid') || img.closest('.gallery-admin')) {
                    img.dataset.optimized = 'true';
                    return;
                }
                this.optimizeImage(img);
            }
        });
    }
    
    // Optimize a single image
    optimizeImage(img) {
        const originalSrc = img.src;
        const alt = img.alt || '';
        const className = img.className;
        
        // Create optimized version
        const optimizedImg = this.createOptimizedImage(originalSrc, alt, className);
        
        // Replace original image
        img.parentNode.replaceChild(optimizedImg, img);
        optimizedImg.dataset.optimized = 'true';
    }
    
    // Lazy load with intersection observer
    setupLazyLoading() {
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    
                    // Load the actual image
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                    }
                    
                    // Load srcset if available
                    if (img.dataset.srcset) {
                        img.srcset = img.dataset.srcset;
                        img.removeAttribute('data-srcset');
                    }
                    
                    observer.unobserve(img);
                }
            });
        }, {
            rootMargin: '50px 0px',
            threshold: 0.01
        });
        
        // Observe all lazy images
        document.querySelectorAll('img[data-src]').forEach(img => {
            imageObserver.observe(img);
        });
    }
    
    // Preload critical images
    preloadCriticalImages(urls) {
        urls.forEach(url => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.as = 'image';
            link.href = url;
            document.head.appendChild(link);
        });
    }
    
    // Generate WebP URLs if supported
    generateWebPUrl(originalUrl) {
        if (!this.supportedFormats || !originalUrl.includes('cloudinary')) {
            return originalUrl;
        }
        
        return originalUrl.replace('/upload/', '/upload/f_webp,q_auto/');
    }
    
    // Get image dimensions for layout optimization
    async getImageDimensions(url) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                resolve({
                    width: img.naturalWidth,
                    height: img.naturalHeight,
                    aspectRatio: img.naturalWidth / img.naturalHeight
                });
            };
            img.onerror = () => {
                resolve({ width: 0, height: 0, aspectRatio: 1 });
            };
            img.src = url;
        });
    }
}

// Initialize image optimizer
const imageOptimizer = new ImageOptimizer();

// Export for use in other scripts
window.imageOptimizer = imageOptimizer;

// Auto-optimize images when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    imageOptimizer.optimizePageImages();
    imageOptimizer.setupLazyLoading();
});

// Optimize images added dynamically
const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
            if (node.nodeType === 1) { // Element node
                const images = node.querySelectorAll ? node.querySelectorAll('img') : [];
                images.forEach(img => imageOptimizer.optimizeImage(img));
            }
        });
    });
});

observer.observe(document.body, {
    childList: true,
    subtree: true
});


// request-optimizer.js
/**
 * Request Optimization
 * Debouncing, throttling, and request batching for better performance
 */

class RequestOptimizer {
    constructor() {
        this.debounceTimers = new Map();
        this.throttleTimers = new Map();
        this.requestQueue = [];
        this.batchSize = 10;
        this.batchTimeout = 100; // ms
        this.isProcessingBatch = false;
    }
    
    // Debounce function calls
    debounce(key, func, delay = 300) {
        if (this.debounceTimers.has(key)) {
            clearTimeout(this.debounceTimers.get(key));
        }
        
        const timer = setTimeout(() => {
            func();
            this.debounceTimers.delete(key);
        }, delay);
        
        this.debounceTimers.set(key, timer);
    }
    
    // Throttle function calls
    throttle(key, func, limit = 100) {
        if (this.throttleTimers.has(key)) {
            return; // Skip if throttled
        }
        
        func();
        
        this.throttleTimers.set(key, true);
        setTimeout(() => {
            this.throttleTimers.delete(key);
        }, limit);
    }
    
    // Batch multiple requests
    batchRequest(requestFunc, data) {
        return new Promise((resolve, reject) => {
            this.requestQueue.push({
                func: requestFunc,
                data: data,
                resolve: resolve,
                reject: reject
            });
            
            if (this.requestQueue.length >= this.batchSize) {
                this.processBatch();
            } else if (!this.isProcessingBatch) {
                setTimeout(() => {
                    this.processBatch();
                }, this.batchTimeout);
            }
        });
    }
    
    // Process batched requests
    async processBatch() {
        if (this.isProcessingBatch || this.requestQueue.length === 0) {
            return;
        }
        
        this.isProcessingBatch = true;
        const batch = this.requestQueue.splice(0, this.batchSize);
        
        try {
            // Group similar requests
            const groupedRequests = this.groupRequests(batch);
            
            // Process each group
            for (const [type, requests] of Object.entries(groupedRequests)) {
                await this.processRequestGroup(type, requests);
            }
        } catch (error) {
            console.error('Error processing batch:', error);
            // Reject all requests in batch
            batch.forEach(({ reject }) => reject(error));
        } finally {
            this.isProcessingBatch = false;
            
            // Process remaining requests
            if (this.requestQueue.length > 0) {
                setTimeout(() => {
                    this.processBatch();
                }, this.batchTimeout);
            }
        }
    }
    
    // Group similar requests
    groupRequests(batch) {
        const groups = {};
        
        batch.forEach(({ func, data }) => {
            const key = func.name || func.toString();
            if (!groups[key]) {
                groups[key] = [];
            }
            groups[key].push({ func, data });
        });
        
        return groups;
    }
    
    // Process a group of similar requests
    async processRequestGroup(type, requests) {
        if (type.includes('getGalleryPhotos')) {
            // Batch gallery photo requests
            const uniqueParams = this.getUniqueParams(requests);
            const results = await Promise.all(
                uniqueParams.map(params => requests[0].func(...params))
            );
            
            // Distribute results to appropriate requests
            requests.forEach(({ resolve }, index) => {
                resolve(results[index] || results[0]);
            });
        } else {
            // Process individually
            const results = await Promise.all(
                requests.map(({ func, data }) => func(data))
            );
            
            requests.forEach(({ resolve }, index) => {
                resolve(results[index]);
            });
        }
    }
    
    // Get unique parameters from requests
    getUniqueParams(requests) {
        const params = new Set();
        requests.forEach(({ data }) => {
            params.add(JSON.stringify(data));
        });
        return Array.from(params).map(param => JSON.parse(param));
    }
    
    // Optimized search with debouncing
    createDebouncedSearch(searchFunc, delay = 500) {
        return (query) => {
            return new Promise((resolve) => {
                this.debounce(`search_${query}`, async () => {
                    const result = await searchFunc(query);
                    resolve(result);
                }, delay);
            });
        };
    }
    
    // Optimized scroll handler with throttling
    createThrottledScrollHandler(handler, limit = 100) {
        return (event) => {
            this.throttle('scroll_handler', () => {
                handler(event);
            }, limit);
        };
    }
    
    // Optimized resize handler with debouncing
    createDebouncedResizeHandler(handler, delay = 250) {
        return (event) => {
            this.debounce('resize_handler', () => {
                handler(event);
            }, delay);
        };
    }
    
    // Cancel pending requests
    cancelRequest(key) {
        if (this.debounceTimers.has(key)) {
            clearTimeout(this.debounceTimers.get(key));
            this.debounceTimers.delete(key);
        }
        
        if (this.throttleTimers.has(key)) {
            this.throttleTimers.delete(key);
        }
    }
    
    // Clear all pending requests
    clearAll() {
        this.debounceTimers.forEach(timer => clearTimeout(timer));
        this.debounceTimers.clear();
        this.throttleTimers.clear();
        this.requestQueue = [];
    }
    
    // Get optimization stats
    getStats() {
        return {
            debounceTimers: this.debounceTimers.size,
            throttleTimers: this.throttleTimers.size,
            queuedRequests: this.requestQueue.length,
            isProcessingBatch: this.isProcessingBatch
        };
    }
}

// Initialize request optimizer
const requestOptimizer = new RequestOptimizer();

// Export for use in other scripts
window.requestOptimizer = requestOptimizer;

// Example usage:
// const debouncedSearch = requestOptimizer.createDebouncedSearch(searchPhotos);
// const throttledScroll = requestOptimizer.createThrottledScrollHandler(handleScroll);
// const debouncedResize = requestOptimizer.createDebouncedResizeHandler(handleResize);


// performance-monitor.js
/**
 * Performance Monitor
 * Tracks loading times and user experience metrics
 */

class PerformanceMonitor {
    constructor() {
        this.metrics = {
            pageLoadTime: 0,
            domContentLoaded: 0,
            firstContentfulPaint: 0,
            imagesLoaded: 0,
            totalImages: 0,
            lazyLoadSavings: 0
        };
        
        this.init();
    }
    
    init() {
        // Track page load time
        window.addEventListener('load', () => {
            this.metrics.pageLoadTime = performance.now();
            this.logMetrics();
        });
        
        // Track DOM content loaded
        document.addEventListener('DOMContentLoaded', () => {
            this.metrics.domContentLoaded = performance.now();
        });
        
        // Track First Contentful Paint
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.name === 'first-contentful-paint') {
                        this.metrics.firstContentfulPaint = entry.startTime;
                    }
                }
            });
            observer.observe({ entryTypes: ['paint'] });
        }
        
        // Track image loading
        this.trackImageLoading();
        
        // Track lazy loading savings
        this.trackLazyLoading();
    }
    
    trackImageLoading() {
        const images = document.querySelectorAll('img');
        this.metrics.totalImages = images.length;
        
        let loadedImages = 0;
        images.forEach(img => {
            if (img.complete) {
                loadedImages++;
            } else {
                img.addEventListener('load', () => {
                    loadedImages++;
                    this.metrics.imagesLoaded = loadedImages;
                });
            }
        });
    }
    
    trackLazyLoading() {
        const lazyImages = document.querySelectorAll('img[loading="lazy"]');
        this.metrics.lazyLoadSavings = lazyImages.length;
        
        // Calculate potential bandwidth savings
        const estimatedSavings = lazyImages.length * 100; // Assume 100KB per image
        console.log(`Lazy loading enabled for ${lazyImages.length} images. Estimated bandwidth savings: ${estimatedSavings}KB`);
    }
    
    logMetrics() {
        console.log('📊 Performance Metrics:');
        console.log(`Page Load Time: ${this.metrics.pageLoadTime.toFixed(2)}ms`);
        console.log(`DOM Content Loaded: ${this.metrics.domContentLoaded.toFixed(2)}ms`);
        console.log(`First Contentful Paint: ${this.metrics.firstContentfulPaint.toFixed(2)}ms`);
        console.log(`Images Loaded: ${this.metrics.imagesLoaded}/${this.metrics.totalImages}`);
        console.log(`Lazy Loading Savings: ${this.metrics.lazyLoadSavings} images`);
        
        // Send metrics to analytics (if available)
        this.sendMetrics();
    }
    
    sendMetrics() {
        // You can send these metrics to your analytics service
        // Example: Google Analytics, Firebase Analytics, etc.
        if (typeof gtag !== 'undefined') {
            gtag('event', 'performance_metrics', {
                page_load_time: this.metrics.pageLoadTime,
                dom_content_loaded: this.metrics.domContentLoaded,
                first_contentful_paint: this.metrics.firstContentfulPaint,
                images_loaded: this.metrics.imagesLoaded,
                total_images: this.metrics.totalImages,
                lazy_load_savings: this.metrics.lazyLoadSavings
            });
        }
    }
    
    // Get current metrics
    getMetrics() {
        return this.metrics;
    }
}

// Initialize performance monitor
const performanceMonitor = new PerformanceMonitor();

// Export for use in other scripts
window.performanceMonitor = performanceMonitor;

